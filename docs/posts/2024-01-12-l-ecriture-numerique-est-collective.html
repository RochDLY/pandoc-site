<!DOCTYPE html>
<html lang="fr" xml:lang="fr">
    <head>
        <meta charset="utf-8"/>

        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

        <title>Roch Delannay | L’écriture numérique est collective</title>

        <meta name="author" content="Roch Delannay" />

        <meta name="description" content="Blog | Carnet de recherche de Roch Delannay" />

        <meta name="dcterms.date" content="2024-01-12" />

        <meta name="generator" content="Pandoc, GNU make" />
        <!-- pandoc - https://pandoc.org/ -->
        <!-- gnu make - https://www.gnu.org/software/make/ -->
        <link rel="stylesheet" href="/css/styles.css" />    </head>
    <body>
        <header class="main-header">
            <nav class="navbar">
                <ul>
                    <li><a href="/">Accueil</a></li>
                    <li><a href="/pages/publications.html">Publications & Communications</a></li>
                    <li><a href="/pages/cours.html">Enseignements</a></li>
                    <li><a href="/pages/presentations.html">Présentations</a></li>
                    <li><a href="http://git.en-cours-de.construction/">Sources et versions</a></li>
                    <li class="right"><a href="/index-cache.html"></a></li>

                </ul>
            </nav></header>                <div class="side">

            <nav class="toc">
<ul>
<li><a href="#lécriture-numérique" id="toc-lécriture-numérique">L’écriture numérique</a>
<ul>
<li><a href="#la-controverse-sur-lécriture" id="toc-la-controverse-sur-lécriture">La controverse sur l’écriture</a></li>
<li><a href="#les-particularités-de-lécriture-numérique" id="toc-les-particularités-de-lécriture-numérique">Les particularités de l’écriture numérique</a></li>
<li><a href="#détails-de-laction-décriture-dans-lordinateur" id="toc-détails-de-laction-décriture-dans-lordinateur">Détails de l’action d’écriture dans l’ordinateur</a></li>
</ul></li>
<li><a href="#larchitexte-écrit-dans-le-texte" id="toc-larchitexte-écrit-dans-le-texte">L’architexte écrit dans le texte</a>
<ul>
<li><a href="#définition-de-larchitexte" id="toc-définition-de-larchitexte">Définition de l’architexte</a></li>
<li><a href="#larchitexte-nest-pas-quune-surface" id="toc-larchitexte-nest-pas-quune-surface">L’architexte n’est pas qu’une surface</a></li>
<li><a href="#dépassement-de-lécran-et-de-la-page" id="toc-dépassement-de-lécran-et-de-la-page">Dépassement de l’écran et de la page</a></li>
<li><a href="#ce-que-larchitexte-inscrit-dans-le-support" id="toc-ce-que-larchitexte-inscrit-dans-le-support">Ce que l’architexte inscrit dans le support</a></li>
<li><a href="#assujetissement-à-larchitexte-et-aux-formats" id="toc-assujetissement-à-larchitexte-et-aux-formats">Assujetissement à l’architexte et aux formats</a></li>
</ul></li>
<li><a href="#étude-de-cas-léditeur-de-texte-stylo" id="toc-étude-de-cas-léditeur-de-texte-stylo">Étude de cas : l’éditeur de texte Stylo</a>
<ul>
<li><a href="#quest-ce-que-stylo" id="toc-quest-ce-que-stylo">Qu’est-ce que Stylo ?</a></li>
<li><a href="#les-formats-pivots-de-stylo-en-détail" id="toc-les-formats-pivots-de-stylo-en-détail">Les formats pivots de Stylo en détail</a></li>
<li><a href="#écrire-avec-stylo" id="toc-écrire-avec-stylo">Écrire avec Stylo</a></li>
</ul></li>
<li><a href="#conclusion-1" id="toc-conclusion-1">Conclusion</a></li>
</ul>
            </nav>
        </div>
                    <div class="container">
                <header class="header-bloc">
                    <h1>L’écriture numérique est collective</h1>
<!--  -->
                    <time>2024-01-12</time>
<!--                     <p>Roch Delannay</p>
 -->
                </header>
                <div class="content">
<p>Résumé : En suivant les pensées de l’éditorialisation et de l’énonciation éditoriale, l’écriture numérique n’est plus le seul produit d’une fonction auctoriale, mais d’un ensemble de fonctions éditoriales dont la fonction auctoriale fait partie. Cet ensemble comprend à la fois des interventions humaines mais aussi des interventions réalisées par la machine, à travers une série de choix technologiques particuliers, que l’on peut englober sous le terme de chaîne éditoriale. Selon ce dispositif, et puisque notre hypothèse positionne l’intime en tant que produit de l’écriture, nous pouvons nous demander si l’ensemble des fonctions éditoriales ne participeraient-elles pas à produire l’intimité du chercheur et à transformer ainsi l’intimité en intimité collective ?</p>
<p>[Note : il s’agit certainement de la problématique de toute la thèse, dans cette partie on peut se focaliser uniquement sur l’apport de la machine dans cette intimité (et les autres chapitres sur peer review entre autre et les mémoires)]</p>
<p>Parmi toutes les fonctions éditoriales que l’on pourrait énumérer, nous allons nous concentrer sur la fonction écriture de l’architexte. Cet environnement peut être découpé en deux parties : les logiciels et les matériels. En fonction de la configuration choisie pour écrire, un auteur peut écrire d’une certaine manière et pas d’une autre. Yves Jeanneret et Emmanuël Souchier emploient la notion d’architexte pour expliquer la Pour montrer les particularités d’un environnement, une étude sur l’environnement d’écriture avec l’éditeur de texte sémantique Stylo</p>
<h2 id="lécriture-numérique">L’écriture numérique</h2>
<h3 id="la-controverse-sur-lécriture">La controverse sur l’écriture</h3>
<p>Définir l’écriture tient généralement de l’anthropologie ou des lettres, la controverse à ce sujet est très large. Christin en dresse la cartographie en distingant deux tendances principales : l’écriture selon les traces ou selon les signes. Dans un cas comme dans l’autre, ce qui défini finalement l’écriture est l’inscription dans la matière.</p>
<h3 id="les-particularités-de-lécriture-numérique">Les particularités de l’écriture numérique</h3>
<p>Lorsqu’il s’agit de convoquer <em>l’écriture numérique</em> nous pensons tout de suite à un ordinateur, aux claviers, aux écrans et au pointeur qui clignote dans un éditeur de texte ou dans le champ d’un formulaire en ligne. Avec le numérique ubiquitaire (Citton), ces pratiques d’écriture sont ancrées dans nos habitudes au point de ne plus les remettre en question (trouver la ref). Les dispositifs d’écriture analogique sont ainsi renvoyés à l’état de vestiges archaïques : par exemple, les machines à écrire, fabriquées méticuleusement par des ingénieurs et des designers et qui ont fait la fierté et la renommée de certaines entreprises comme Olivetti en Italie, sont complètement désuètes et inutilisées depuis une trentaine d’années. Elles sont aujourd’hui exposées dans des musées (entre autres au MoMA et au Centre Pompidou) et appartiennent aux collections permanentes ou sont exhibées lors d’exposition en lien avec les designers qui les ont conçues<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<figure>
<img src="https://www.photo.rmn.fr/CorexDoc/RMN/Media/TR1/YECPH3/07-521403.jpg" title="Machine à écrire portative" alt="Machine à écrire portative" />
<figcaption aria-hidden="true">Machine à écrire portative</figcaption>
</figure>
<p>Crédits : © Adagp, Paris. Crédit photographique : Georges Meguerditchian - Centre Pompidou, MNAM-CCI /Dist. RMN-GP. Réf. image : 4N40151. Diffusion image : <a href="https://www.photo.rmn.fr/C.aspx?VP3=SearchResult&amp;IID=2C6NU0CU7GAD">l’Agence Photo de la RMN</a></p>
<figure>
<img src="https://www.photo.rmn.fr/CorexDoc/RMN/Media/TR1/VYKH9X/13-519016.jpg" title="Publicité pour la machine à écrire Valentine" alt="Publicité pour la machine à écrire Valentine" />
<figcaption aria-hidden="true">Publicité pour la machine à écrire Valentine</figcaption>
</figure>
<p>Crédits : © Adagp, Paris. Crédit photographique : Jean-Claude Planchet - Centre Pompidou, MNAM-CCI /Dist. RMN-GP. Réf. image : 4F40212 [2003 CX 6098]. Diffusion image : <a href="https://www.photo.rmn.fr/C.aspx?VP3=SearchResult&amp;IID=2C6NU0DWCD6W">l’Agence Photo de la RMN</a></p>
<p>Pourtant, les derniers modèles fabriqués par ces entreprises l’ont été dans les années 1980 ou 1990, comme c’est le cas de l’ETP 55 Portable<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>) et y intègrent des composants électroniques dès la fin des années 1970. Les constructeurs ont opéré un changement de paradigme de l’analogique vers le numérique à ce moment-là et suivi les innovations technologiques informatiques. Pour preuve, en 1983, Perry A. King et Antonio Macchi Cassia réussissent à produire le premier ordinateur personnel d’Olivetti avec le M10 en adaptant un clavier à un écran à cristaux liquide. Cet ordinateur, équipé du processeur Intel 80C85 en 8-bits, pouvait également se connecter à tout un ensemble de périphériques comme des imprimantes.</p>
<figure>
<img src="http://munk.org/typecast/wp-content/uploads/2014/08/15635.jpg" title="Photo d&#39;un M10" alt="Photo d’un M10" />
<figcaption aria-hidden="true">Photo d’un M10</figcaption>
</figure>
<p>Crédits : Photo trouvée sur le blog <a href="https://munk.org/typecast/2014/08/03/back-to-the-future-pram-and-the-promise-of-unified-memory-again/">Munk.org</a> le 22 février 2024.</p>
<p>Il faut se rappeler qu’au début des années 1980 il n’est pas encore certain que l’ordinateur personnel (avec sa tour et son écran à tube cathodique) deviendra l’outil d’écriture par excellence. À cette époque, les machines à écrire ont encore quelques avantages sur les plans esthétique, financier et sociales puisqu’elles sont encore implantées à la fois dans les sphères professionnelles et personnelles.</p>
<p>Matthew Kirschenbaum détaille dans son ouvrage (ref) la bataille entre les fournisseurs de logiciels de traitement de texte durant cette décennie pour obtenir en obtenir le monopole. Avant l’avènement des interfaces graphiques, la seule chose affichée à l’écran était un terminal et la navigation se faisait au moyen de commandes (rappeler les premiers logiciels). De plus, en dehors de logiciels plus complexe comme <code>TeX</code>, développé par Donald Knuth, il n’était pas aisé de gérer la mise en page des documents depuis des éditeurs de texte ou premiers traitements de texte. Ainsi, écrire sur un support connecté paraît aujourd’hui être une évidence alors qu’elle a demandé de lourds efforts à une époque où cette évidence était incertaine.</p>
<p>L’écriture numérique est ainsi à distinguer de l’écriture dans un environnement numérique : un ordinateur, Internet, le Web, une calculatrice ou une machine à écrire. En tant qu’abstraction, l’écriture numérique est une représentation du monde donnée, dont la qualification à travers un medium permet de l’incarner physiquement mais pas de la circonscrire. Cette représentation numérique du monde n’est pas nouvelle et ce n’est pas l’ordinateur qui l’a apporté. À notre connaissance, son origine remonte aux prémices de l’écriture et des développements des systèmes monétaires, nous dit C. Herrenschmidt (2007).</p>
<p>Dorénavant, lorsque nous ferons référence à l’écriture numérique nous parlerons d’une écriture numérique dans un environnement informatique.</p>
<p>L’écriture numérique diffère d’une écriture plus traditionnelle (du monde de l’imprimerie) et se distingue notamment par deux caractéristiques que sont la calculabilité et la séparation du geste et de l’inscription.</p>
<p>La première caractéristique est d’ordre computationnel : l’écriture devient calculable et peut donc faire l’objet d’instructions (Crozat, Bouchardon, Petit, Kembellec, Herrenschmidt, Vitali-Rosati, Kittler, Bachimont, Merzeau). Pour réaliser cette prouesse dans un environnement informatique, on procède a une équivalence où chaque signe que l’on peut y inscrire à son pendant unique sous forme de <em>bits</em>. Lorsque chaque caractère peut être identifié en tant que nombre, il devient possible d’implémenter ce modèle dans une machine et de lui demander, sous forme d’instructions, d’appliquer des calculs.</p>
<p>L’exemple idéal pour illustrer cette caractéristique n’est rien de moins que la machine imaginée par Alan Turing, qu’il présente en 1936 dans son article “On Computable Numbers, with an Application to the Entscheidungsproblem” dans la section <em>Computing machines</em>. Il ne s’agit pas d’une machine physique mais d’un modèle théorique, une machine abstraite fondamentale pour les développements futurs de l’informatique. Cette machine est constituée de plusieurs éléments :</p>
<ul>
<li>un ruban (<em>tape</em>) divisé en sections (appelées <em>squares</em>) dont chacune peut porter un symbole (0 ou 1 car cette machine est dans un système binaire).</li>
<li>un organe de lecture (<em>scan</em>) pour lire les symboles un à un (<em>scanned square and scanned symbol</em>) et d’écriture pour modifier un symbole ou en écrire une nouveau si la section est vide</li>
<li>une mémoire pour se rappeler des sections déjà scannées (<em>remember some of the symbols which it has “seen” (scanned) previously</em>)</li>
<li>des instructions pour se déplacer sur le ruban, soit une case vers la gauche soit une case vers la droite, lire et écrire (<em>scan and print</em>) ou modifier la case scannée et se redéplacer (ou s’arrêter).</li>
</ul>
<p>Théoriquement, le ruban sur lequel la machine exécute ses programmes est infini vers la gauche et vers la droite et cela afin de permettre l’exécution des instructions les plus complexes. La machine de Turing ne s’intéresse pas aux résultats des instructions, ni à leur signification. L’espace de la machine, aussi vaste soit-il, n’est composé que de séries de 0 et de 1 et de différents états, renvoyant à des instructions, permettant ainsi à la machine de modifier son propre espace.</p>
<p>Le passage du signe à l’unité atomique et discrète qu’est le chiffre signifie un changement de représentation du monde (cf <em>worldview</em> de K. Hayles) : le monde n’est alors plus signifié par des mots ou des concepts mais le devient par des chiffres. Comme McLuhan nous le rappelle dès 1964, les alphabets composés de lettres (contrairement à ceux composés de pictogrammes) sont asémantiques. Si toutefois les alphabets sont liés à une culture d’où ils émergent, l’abstraction nécessaire pour représenter le monde sous forme de chiffres détacherait <em>a priori</em> cette vision de tout sens. En dehors de tout modèle mathématiques abstrait, et cela quel que soit le langage ou la base utilisée pour l’écrire, <code>3</code>, <code>trois</code>, <code>three</code>, <code>III</code>, <code>0011</code>, <code>zéro zéro un un</code>, un chiffre ne signifie pas grand chose s’il n’est pas associé à un système de valeurs particulier, par exemple le système métrique ou le système international (Herrenschmidt 2007, voir intro).</p>
<p>En échange de cette perte de signification, l’écriture numérique y gagne cette particularité d’être calculable et mesurable. Dès lors, il devient possible de mesurer des distances ou des écarts entre des lettres, des mots ou des concepts, des données dans un environnement donné.</p>
<p>[ajouter une note sur le propos de Luca Paltrienieri]</p>
<p>L’écriture numérique se distingue également des autres types d’écriture par une deuxième caractéristique. Il s’agit de la première forme d’écriture où le geste d’écrire ne correspond pas à l’action d’inscription du signe sur son support. Lorsqu’on appuie sur une touche du clavier, par exemple la lettre <code>a</code>, cette lettre n’est pas inscrite à l’écran : on donne une instruction à la machine d’inscrire un signe dans la mémoire de l’ordinateur, puis de l’afficher à l’écran avec un logiciel particulier (Kittler, Souchier, etc). Pour comprendre un peu mieux cette particularité, nous pouvons observer le fonctionnement d’un ordinateur.</p>
<h3 id="détails-de-laction-décriture-dans-lordinateur">Détails de l’action d’écriture dans l’ordinateur</h3>
<p>La représentation d’un ordinateur contemporain est un souvent associé à un couple matériel/logiciel (que l’on trouve fréquemment sous l’appellation anglaise <em>hardware</em>/<em>software</em>). La partie matérielle concerne tous les composants électroniques (carte mère, mémoires, périphériques, etc.), alors que la partie logicielle englobe tous les programmes permettant d’interagir avec la partie matérielle, comme le BIOS (<em>Basic Input Output System</em>), le système d’exploitation ou encore un logiciel de traitement de texte.</p>
<p>Ce couple matériel/logiciel permet de ranger l’ordinateur dans une catégorie particulière de machines : les appareils programmables.</p>
<p>La plupart de nos appareils du quotidien ne sont pas programmables : ils exécutent ce pour quoi ils sont conçus et ne font rien d’autre. Dans le cas d’un ordinateur (ou d’un téléphone intelligent) ou de tout autre appareil programmable, ces appareils sont conçus pour être manipulable comme on le souhaite et d’adapter le traitement des informations en conséquence : ils n’ont pas une fonction précise, au contraire ce sont des machines capable de répondre à plusieurs fonctions. C’est là que les logiciels interviennent : ils permettent un usage déterminé d’un ordinateur en manipulant des informations de manière à exécuter une suite d’instructions données.</p>
<h4 id="fonctionnement-de-la-partie-matérielle">Fonctionnement de la partie matérielle</h4>
<p>Pour fonctionner, un ordinateur n’a besoin que des éléments suivants : une alimentation, un processeur, une mémoire vive, des entrées et sorties et une carte mère auquel viennent s’ajouter un certains nombre de périphériques (écrans, souris, clavier, etc.), des extensions pour prendre en charge une partie des calculs (carte son, carte graphique) et des mémoires de stockage (disques durs) entre autres.</p>
<p>Le processeur, ou microprocesseur pour les ordinateurs modernes, est le calculateur central de l’ordinateur, c’est cet élément qui manipule toutes les données à traiter – que l’on appelle aussi le(s) coeur(s) de l’ordinateur. Chaque modèle de processeur à une architecture qui lui est propre, ce qui veut dire que chacun traite les informations <strong>différemment</strong> (même si le résultat obtenu est identique). Un processeur est un assemblage de multiples types de circuits dont l’élément le plus petit est le transistor. L’évolution des processeur a suivi la Loi Moore jusqu’au début des années 2020<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, date à partir de laquelle nous arrivons à la limite physique de la miniaturisation d’un transistor.</p>
<p>Le premier processeur commercialisé, le processeur Intel 4004, l’a été en 1971<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Il s’agissait d’un processeur 4-bits comportant pas moins de 2300 transistors. Lors de la commercialisation de cet objet s’opère un changement radical dans la conception des ordinateurs puisque, dès lors, du fait de la miniaturisation de ce composant, les ordinateurs deviennent accessibles au grand public. En suivant la première loi de Moore, les microprocesseurs ont continué à évoluer jusqu’à atteindre le nombre de plusieurs milliards de transistors par processeur, démultipliant ainsi leur capacité de traitement des informations.</p>
<p>Cette miniaturisation est rendue possible par la gravure des transistors dans des disque de silice (<em>wafer</em>) plutôt que l’usage plus couteux et instable de relais et tubes électroniques. Un transistor est un composant électronique dont le rôle est de laisser passer le courant ou non grâce aux propriétés du semi-conducteur à partir duquel il est fabriqué. En fonction de la valeur du courant qui lui est appliqué, le résultat associé à cette valeur sera <code>0</code> ou <code>1</code>. Ce transistor est l’élément physique qui incarne les portes logiques (ET, OU, OUI, NON, XOR, etc.) et traitent toutes les données. Parmi tous les traitements possibles, certains nécessitent de garder en mémoire des résultats intermédiaires, ainsi, ces données temporaires nécessaires aux traitements sont enregistrées dans la mémoire vive de l’ordinateur.</p>
<p>Ce stockage intermédiaire mène à la question de la mémoire : on en retrouve plusieurs types blablabla (RAM et ROM). Le principe de fonctionnement des mémoires vives (RAM) est le même que pour les processeurs : ce sont des mémoires construites sur la base de transistors et/ou portes logiques.</p>
<p>Ces informations traitées, transformées et mémorisées proviennent de ce que l’on nomme des <em>entrées</em> : ce sont elles qui encodent les informations en chiffres. Une fois traitées, ou lorsque l’on souhaite s’en servir, ces données passent par des <em>sorties</em>. Les sorties font le travail inverse des entrées et décodent les chiffres en signes interprétables.</p>
<h4 id="le-codage-de-linformation">Le codage de l’information</h4>
<p>L’encodage et le décodage des caractères accompagne toute l’histoire de l’informatique (et du numérique). Au prémices de l’informatique, chaque matériel comportait ses propres programmes et tables d’encodage, rendant ainsi possible la transposition des données d’un matériel à un autre. Cependant, dans la plupart des cas, les données ne pouvaient pas circuler entre les différents modèles d’ordinateur, ou alors au moyen de transformations fastidieuses, rendant ainsi les traitements réalisés sur les données enfermés dans des silos. La norme ASCII (<em>American Standard Code for Information Interchange</em>) fait sont apparition dans les années 1960 pour résoudre les enjeux liés à l’encodage des données. Soumise à l’<em>American Standards Association</em> (d’abord ASA puis ANSI) en 1961 par l’un de ses inventeurs, Bob Bemer, puis approuvée en 1963, l’ASCII permet d’encoder 128 caractères sur 7 bits. Néanmoins, ce n’est pas parce qu’un encodage est reconnue en tant que norme que son usage est effectif à l’instant même de la reconnaissance. Il faut attendre 1968 que le président des États-Unis Johnson demande à ce que l’ASCII devienne la norme fédérale d’encodage des informations afin de réduire les incompatibilités au sein des réseaux de télécommunications pour qu’elle commence à se répandre. Dès 1969, tous les ordinateurs achetés par le gouvernement des États-Unis étaient compatibles avec la norme ASCII. Du côté des ordinateurs personnels, il faudra attendre le début des années 1980 pour que cette norme se répande grâce, entre autre, à son implémentation dans les ordinateurs construits par IBM. La norme X3.4:1986 en vigueur aujourd’hui, a été déposée auprès de l’ANSI en 1986. C’est à partir de cette norme que d’autres ont été développées et sont compatibles ASCII, comme c’est par exemple le cas pour la norme Unicode, publiée en 1991, qui est la plus répandue de nos jours, car c’est elle qui encode le plus de caractères. Si ASCII contient 128 points de code, le standard Unicode permet d’en encoder plus de 149 000 sur une vingtaine de bits par point de code dans sa version 15.1 (de 2023). Afin de préserver cette compatiblité entre les normes, il est d’usage d’encoder les 128 premiers caractères de façon identique à la norme ASCII.</p>
<h4 id="fonctionnement-du-software-les-différentes-piles">Fonctionnement du software (les différentes piles)</h4>
<p>Bios, OS, Logiciels, réseaux (protocoles HTTP, TCP/IP, IMAP, POP, REST, GrapHQL), communication entre les différentes couches et fonctionnement de l’inscription dans le disque dur (HDD et SSD).</p>
<p>Le protocole HTTP a été conçu pour permettre la communication entre un client et un serveur. Les méthode de communication les plus couramment utilisée sont <code>GET</code> et <code>POST</code>. Par convention, et afin de limiter d’éventuels effets de bord, la méthode <code>GET</code> permet de récupérer des informations sur le serveur et de les afficher sur la page web tandis que <code>POST</code> permet de les envoyer depuis le client sur le serveur, soit pour ajouter une nouvelle entrée, soit pour la modifier.</p>
<p>[Aux machines distantes (Serveurs, fibre optique, ADSL … Histoire de l’Internet physique)]</p>
<h4 id="conclusion">Conclusion</h4>
<p>[Si j’écris la chaine de caractère “Hello world” elle passe par (décrire les éléments) jusqu’à cet encodage dans le disque dur, voir si l’écriture avec une autre architecture propose un encodage différent]</p>
<p>Ce que l’on remarque en regardant de près cette configuration de l’environnement d’écriture numérique est qu’il n’est pas possible d’écrire sur le disque dur sans un agent intermédiaire : le logiciel.</p>
<h2 id="larchitexte-écrit-dans-le-texte">L’architexte écrit dans le texte</h2>
<h3 id="définition-de-larchitexte">Définition de l’architexte</h3>
<p>Sans l’intervention du logiciel comme médiateur entre l’être humain et le support d’inscription de l’écriture numérique, il ne serait pas possible pour l’auteur d’écrire dans cet environnement. Si l’on considère l’écriture comme le geste d’inscrire une trace ou un signe dans un support, alors l’écriture numérique n’est plus un fait humain mais un acte réalisé par l’ordinateur lui-même.</p>
<p>L’interaction entre un humain et une machine consiste en une série d’instructions que donne l’utilisateur à la machine qui, ensuite, les exécute. Le mécanisme sous-jacent à ce que l’on considère communément comme l’écriture numérique (frapper une touche du clavier et voir la lettre s’afficher à l’écran) s’avère plus complexe. Le moment de la frappe n’est plus le moment où le symbole est inscrit dans le disque dur, mais est le moment où une instruction est donnée à l’ordinateur qui ensuite se charge d’inscrire la lettre correspondante sur le disque dur. Si l’on se trouve dans le cas de figure de la saisie d’un texte dans un éditeur de texte, l’instruction suivante, selon les logiciels et les actions souhaitées, consiste à afficher le symbole encodé sur le disque dur à l’écran.</p>
<p>Pour réaliser ces actions, Yves Jeanneret et Emmanuël Souchier partent de ce constat qu’il n’est pas possible d’écrire un texte sans qu’un autre texte soit déjà présent pour réaliser cette action. Ce texte particulier qui pré-existe toute activité numérique est nommé <em>architexte</em> (refs x, x, 2019).</p>
<p>L’architexte a d’abord été employé en littératures par Gérard Genette (1979) et désigne « l’ensemble des catégories générales, ou transcendentes – types de discours, modes d’énonciations, genres littéraires, etc. –, dont relève chaque texte singulier ».</p>
<p>En 2019, dans l’ouvrage intitulé <em>Le numérique comme écriture</em>, Gustavo Gomez-Mejia, Étienne Candel et Emmanuël Souchier résument la notion d’architexte comme :</p>
<blockquote>
<p>Initialement défini comme une « écriture d’écriture » puis comme un « dispositif d’écriture écrit », l’architexte s’avère être un point de passage obligé pour toute activité numérique. Il n’y a effectivement pas d’écriture à l’écran sans un architexte qui la rend possible, l’accompagne et la formate. Pour la première fois de son histoire, l’homme a donc recours à des « dispositifs d’écriture écrits » spécifiques pour pouvoir pratiquer une activité d’écriture (E. Souchier, 1998, 2013). Or, précisément en ce qu’ils sont « eux-mêmes écrits », les architextes « sont des textes lisibles et interprétables. Porteurs et prescripteurs d’une écriture à venir, ils anticipent de ce fait une figure de l’auteur » (É. Candel, G. Gomez Mejia, 2013) et relèvent donc de « l’énonciation éditoriale » (E. Souchier, 1998).</p>
</blockquote>
<p>Globalement, l’architexte incarne le cadre dans lequel les agents peuvent écrire. Il permet de faire la distinction entre ce que Marie Depret-Lonnet (ref) nomme gabarit, les espaces proposés par les éditeurs de logiciels ou applications pour écrire, et le texte saisi par l’utilisateur, c’est-à-dire le texte qui vient remplir le gabarit. Cet architexte, ce cadre, est régit par des règles qui définissent comment l’on peut écrire mais surtout comment les signes à inscrire doivent être formatés.</p>
<h4 id="revue-de-la-littérature-mobilisant-larchitexte">Revue de la littérature mobilisant l’architexte</h4>
<p>Goody</p>
<h3 id="larchitexte-nest-pas-quune-surface">L’architexte n’est pas qu’une surface</h3>
<p>[Revenir sur Christin et sa critique de Goody]</p>
<p>Nous l’avons vu, l’architexte se positionne en tant que médiateur entre un auteur et la machine qu’il emploie pour écrire. Jusqu’à présent, la définition de l’architexte englobe largement tous les écrits qui permettent d’écrire à l’écran. En 2019 G. Gomez-Mejia, E. Souchier et E. Candel précisent ce que sont ces méta-écritures et en dressent une typologie composée de quatre « cadres d’écrits d’écran » :</p>
<ul>
<li>le matériel</li>
<li>le système</li>
<li>le logiciel</li>
<li>le document</li>
</ul>
<p>Le premier cadre, matériel, désigne toute la composante physique de l’ordinateur et surtout l’écran sur lequel est affiché le texte. Le cadre système, quant à lui, est associé à la couche permettant de générer un environnement d’écriture numérique, initialisé par le BIOS, un <em>firmware</em> flashé dans la mémoire morte de la carte mère de l’ordinateur permettant de réaliser un certains nombre d’instructions lors de la mise sous tension comme par exemple le démarrage du système d’exploitation qui constitue le deuxième élément principal du système. Le cadre logiciel est relatif à l’ensemble des logiciels que l’on peut exécuter dans un système d’exploitation, par exemple un terminal, un navigateur ou un traitement de texte. Enfin, le dernier cadre est celui du document. Le document doit être compris comme un objet, ou une forme, déterminé et à l’intérieur duquel des éléments sémiotiques sont organisés et structurés (Pédauque (2006, 2007), Zacklad).</p>
<p>Ces cadres sont un début de réponse au dépassement de l’écran. Néanmoins, plutôt que d’approfondir cette dimension invisible du texte, les auteurs reviennent sur la couche graphique en ajoutant qu’« à cet enchâssement de cadres, il faudrait encore ajouter ceux que composent, à l’intérieur même du document, les rubriques, encadrés, cartouches, « boîtes de dialogue » ou autres formes de cadres éditoriaux structurants pour le travail même du texte ».</p>
<p>De plus, toujours selon les auteurs :</p>
<blockquote>
<p>Le premier “cadre” [qui] définit les conditions de possibilités matérielles de l’activité, est le seul inanimé. Les trois suivants, cadres système, logiciel et document, relèvent de l’ingénierie textuelle et définissent les conditions de réalisation de l’activité. On voit ainsi qu’une activité d’écriture réalisée sur le « document » d’un logiciel de traitement de texte est mise en abyme au sein de l’ensemble des autres « cadres » qui la rendent possible et la déterminent techniquement et sémiotiquement.</p>
</blockquote>
<p>Ce premier cadre de « l’écrit d’écran » ne désigne, pour les auteurs, que l’écran. Or, il n’est pas nommé <em>cadre écran</em> mais <em>cadre matériel</em> et devrait renvoyer à toute la dimension physique d’un ordinateur et pas seulement à l’organe d’affichage qui, dans cette disposition, apparaît comme central dans le fonctionnement d’un ordinateur.</p>
<p>Le fait de rendre la couche <em>hardware</em> inanimée dans le production du texte écrit et de renvoyer cette production aux couches supérieures crée deux contradictions. La première contradiction efface la fonction éditoriale du <em>hardware</em>, considérée dès lors comme neutre ce qui, paradoxalement, irait à l’encontre de l’énonciation éditoriale (Jeanneret &amp; Souchier) dont l’intérêt est l’observation des dynamiques de production de l’écriture. La deuxième contradiction repose dans la perception du fonctionnement d’un ordinateur. Si l’on pousse ce raisonnement du matériel inanimé, la machine ne pourrait pas inscrire le texte sur un disque dur. Or, nous avons vu que, <em>stricto sensus</em>, c’est bien la machine qui réalise l’action d’écrire/inscrire sur le support. En rendant cette couche inanimée, on y perd la caractéristique de co-écriture défendue par les auteurs auparavant. De plus, le renvoi à la surcouche graphique ajoute un masque supplémentaire à ce que nous essayons de voir en-dessous. Ce que nous pouvons en comprendre est que, finalement, la notion d’architexte telle qu’elle est construite par Souchier <em>et al</em>, est anthropocentrée et s’appuie sur des conventions de lecture (<em>lettrure</em>) humaines.</p>
<p>Le dépassement de l’écran est un acte symbolique nécessaire pour se soustraire à une vision anthropocentrée telle qu’elle vient d’être proposée. Pour ce faire, revenons à l’écriture comme moyen de transmettre une information au sein d’un système donné. En l’astreignant à un système d’informations comprenant seulement des agents humains, il devient difficile d’inclure l’ordinateur comme un agent agissant de ce système. Ce système dispose d’un argument de taille (variable) pour nous conforter dans cette interprétation, l’écran, accompagné d’un objet virtuel qui n’existe que pour nous réconforter dans notre usage de l’ordinateur : la page.</p>
<h3 id="dépassement-de-lécran-et-de-la-page">Dépassement de l’écran et de la page</h3>
<p>Le terme « page » revient de manière récurrente dans nos usages de l’ordinateur : on le retrouve dans les logiciels de traitement de texte (il y a même un logiciel du nom de <em>Pages</em> disponible dans l’environnement Apple), dans les livres numériques ou encore dans le web où chaque URL est l’adresse d’une page. Matthew Kirschenbaum détaille notamment la relation de l’utilisateur à la page dans son ouvrage …</p>
<p>[Ajouter une note sur Kirschenbaum]</p>
<p>Cet objet qu’est la page a été instauré dans l’ordinateur uniquement pour reproduire une « habitude » et créer un lien fictif entre les visions du monde de l’imprimerie et de l’informatique. Cet artefact produit une forme de réconfort auprès de l’utilisateur pour que le monde informatique lui semble plus tangible, qu’il ait quelque chose auquel se raccrocher, d’où sa déclinaison dans des espaces différents, comme le web, qui ne ressemble plus du tout à des pages au format lettre ou A4. La page affichée à l’écran n’existe qu’à cet endroit, il ne s’agit que d’un rendu graphique qui ne fait pas partie de l’écriture (au sens du texte saisi).</p>
<p>Le pouvoir de la page sur l’utilisateur est considérable étant donnée la nature même de cet objet que l’on pourrait considérer comme l’un des seuls à être virtuel et presque sans matérialité du point de vue de l’informatique. Malgré tous les efforts effectués depuis son instauration à l’écran, la page affichée n’est jamais la page imprimée car aussi précis que soient les détails typographiques que l’on peut y ajuster, elle ne reflétera jamais le grain, l’épaisseur, l’odeur ou tout autre caractéristique physique du papier.</p>
<p>La critique énoncée à l’endroit de la page ne doit pas être réduite à une apologie d’un mode sans page. Elle consiste plutôt à montrer qu’à vouloir préserver une habitude pour « ne pas effrayer » l’utilisateur, la page fait écran devant l’ordinateur, et cache la machine qui ne devient plus qu’un simple mécanisme au lieu d’être un agent de l’énonciation éditoriale.</p>
<p>Cette peur de l’informatique relève essentiellement de l’angoisse de l’arrachement d’une valeur qui définie l’être humain et devienne une caractéristique d’une autre entité, ne permettant plus de définir l’humain en regard de ce que lui seul est capable de faire (Vitali-Rosati).</p>
<p>Kittler, à ce propos, nous rappelle qu’historiquement les caractéristiques qui définissent l’être humain sont souvent le symbole du pouvoir et désigne plutôt les hommes alors qu’à l’instant même ou cette caractéristique est déchue de son statut de marqueur d’une puissance, ce sont les femmes qui en héritent et deviennent les expertes en ce domaine (Kittler ref). Il y aurait donc une peur de perdre non seulement une caractéristique de l’humanité mais surtout une caractéristique de la masculinité.</p>
<p>Néanmoins, avant d’en arriver à cette émotion forte qu’est la peur et qui traduit la non capacité à définir l’être humain, nous pouvons nous appuyer sur la pensée de G. Anders et ressentir une forme de honte que l’écran camoufle.</p>
<p>Interagir avec une machine demande une certaine rigueur : qu’il s’agisse de structurer un document ou de lui donner une série d’instructions (du code), une machine ne peut interpréter l’ambiguité ou l’implicite culturel. Cela veut dire qu’aucun échange humain-ordinateur ne peut reposer sur des conventions culturelles de lecture et que l’instruction donnée n’a, en elle-même, aucun sens. Dès lors, comment admettre que quelque chose qui n’a pas de sens puisse en générer ?</p>
<p>La honte (prométhéenne) d’Anders est alors double : d’un côté il y a un mélange de fierté devant cette machine créée par l’être humain et de honte parce que l’individu isolé devant la machine sait que ce n’est pas lui qui l’a mise au point et, de l’autre, il y a cette honte à être face à un outil qui réalise une action mieux qu’on ne le ferait soi-même alors que cette dite machine n’a aucune conscience de ce qu’elle réalise.</p>
<p>Le dépassement de l’écran est une proposition pour poser un autre regard non anthropocentré sur cette question de l’écriture numérique. Elle signifie qu’il ne s’agit plus de poser la question de l’auteur de l’écriture, en admettant que c’est bien la machine qui écrit, et de se demander comment cette nouvelle fonction (inter)agit entre les agents humains. Que se passe-t-il lorsque cet ordinateur devient un agent actif qui écrit et transmet des informations entre, d’une part, l’instructeur (la personne qui donne des instructions) et la ou les personnes qui lisent les productions écrites ? Dans cette configuration s’opère un changement radical de l’état de l’ordinateur. Cette machine passe de l’état de médiateur, de support de l’écriture, à celui d’entité agissante au sein d’un système.</p>
<p>En s’appuyant sur Kittler et sa très célèbre provocation « Es gibt keine Software », traduit par « Le logiciel n’existe pas » …</p>
<p>Katherine Hayles s’inscrit sur les traces de Kittler et propose également une nouvelle perspective sur l’écriture (My mother was a computer et how we become posthuman + parole, écriture, code)…</p>
<p>Il y aurait donc une action du côté de la machine… Le logiciel n’existe pas en tant qu’entité agissante. Ce n’est ni un agent qui écrit (ni un médiateur). C’est bien l’ordinateur qui écrit à travers les instructions qu’il reçoit (de l’utilisateur et de l’éditeur du logiciel de par son code). Ce qui se trouve entre l’ordinateur et l’auteur est du texte qui permet d’écrire à la machine d’écrire du texte. Dans sa conférence sur les logiciels, Kittler démontre que le logiciel est ramené au même niveau que le reste des écritures par l’ordinateur, c’est-à-dire au niveau le plus bas (binaire). En ce sens, les écritures des logiciels ne servent qu’à camoufler le fonctionnement de la machine. Un autre particularité des logiciels que souligne Kittler est qu’un logiciel ne peut pas exister en dehors de son environnement numérique.</p>
<p>L’intermédialité montréalaise peut aider à expliquer ce phénomène (citer ref)</p>
<p>[expliquer intermédialité montréalaise]</p>
<p>Pour aller plus loin dans cette réflexion, nous pouvons même abolir la notion de média au profit de celle de médiation en mobilisant le texte de Larrue et de Vitali-Rosati (Media does not exist)… Cette proposition de Larrue et Vitali-Rosati, qui s’inscrit directement dans la lignée des travaux de Kittler, permet de faire abstraction de l’objet même qu’est le média et de se concentrer sur l’interaction <em>entre</em>, la médiation. Finalement, ce n’est pas l’étude du support (physique) qui doit faire l’objet de l’étude mais la relation ou la dynamique, le <em>flux</em>, entre les différents agents d’où émerge la matérialité.</p>
<p>Kittler fait la même proposition dans sa conférence <em>Le logiciel n’existe pas</em>.</p>
<p>Revenir sur la matérialité (en tant que propriété émergente, citer Hayles) du texte qui est tout sauf affichée sur un écran : l’écran et surtout la surcouche graphique de mise en page est une illusion créée pour le lecteur humain : elle a son importance dès lors que le système d’informations prévoit des destinataires humains mais elle en perd lorsqu’il s’agit d’étudier les relations entre un ordinateur et un auteur.</p>
<p>Or le principal lectorat des textes numériques sont les robots : les textes écrits sont écrits avec des machines et principalement pour les machines (c’est, par exemple, pour cela que le documentaliste déclare formellement les données)(citer Kembellec etc)</p>
<p>La quest</p>
<!-- Une emphase en italique saisie dans le logiciel Microsoft Word ne sera pas
encodée de la même façon que dans le logiciel InDesign.

[ajouter les deux exemples d'encodage]

C'est en ce sens que l'architexte est le « porteur et [le] prescripteur d'une
écriture à venir » car il dépasse le statut d'interface neutre à l'écran et
devient l'agent qui balise, au sens littéral, le texte.

Néanmoins, cette définition de l'architexte le positionne comme un agent passif
qui ne dépasse pas le statut de cadre de l'écriture.
Or, n'est-ce pas l'architexte lui-même qui interprète l'instruction donnée et
l'applique, c'est-à-dire l'écrit, dans le texte ?

Si l'on reprend l'exemple précédent, lorsque l'on donne pour instruction
d'appliquer une emphase en italique à une chaîne de caractère, c'est bien
le logiciel (une des couches de l'architexte) qui inscrit l'emphase selon le
format qui lui est prédéfini.

Néanmoins, cette écriture réalisée par l'architexte n'est pas rendu visible à
l'écran.
L'affichage de l'écriture à l'écran respecte des conventions de lecture propres
à une culture, elles n'est que rarement affichée dans sa forme la plus verbeuse
(complète)  -->
<h3 id="ce-que-larchitexte-inscrit-dans-le-support">Ce que l’architexte inscrit dans le support</h3>
<h4 id="wysiwym-vs-wysiwyg">WYSIWYM vs WYSIWYG</h4>
<p>Selon les formats d’écriture, et lorsqu’on sort du paradigme WYSIWYG pour celui du WYSIWYM, on s’émancipe de la surcouche graphique pour entrer directement dans la couche de la structuration des contenus.</p>
<p><em>What You See Is What You Get</em>, ou WYSIWYG, est l’acronyme généralement employé pour désigner les outils qui adoptent une surcouche graphique pour mettre en page le contenu directement, au risque de ne pas structurer de la façon souhaitée. Le paradigme opposé, <em>What You See Is What You Mean</em>, distingue la mise en page (graphique) du texte de sa structuration. Les formats employées sont généralement en texte brut et permettent souvent de baliser le contenu pour définir la nature des éléments à décrire. C’est le cas par exemple de tous les langages de balisages tels HTML ou XML mais également les langages de balisage léger tels Markdown, AsciiDoc, reStrucredText,…</p>
<p>Arrivé à ce niveau, l’agent humain ne dépend plus d’un logiciel particulier pour saisir son texte mais peut faire le choix de l’environnement dans lequel il veut travailler puisque le texte saisi l’est dans un format brut ce qui, a priori, est réalisable dans tous les environnements de saisi.</p>
<p>Écrire en texte brut signifie également ouvrir les possibilités de structuration du texte même : ce n’est plus Microsoft Word ou LibreOffice qui décident de quelle manière sont structurées les informations mais le choix d’un format ou d’une saveur particulière d’un format.</p>
<p>L’encodage d’un texte en XML illustre bien ce propos. XML pour eXtensible Markup Language; est également un métalangage de balisage et de modélisation du texte. Plus souple que le HTML dont les balises sont figées, XML permet à chaque utilisateur de créer son propre système hiérarchique arborescent par l’élaboration de balises personnalisées. Postérieur d’une décennie au HTML, la publication des recommandations de la première version (1.0) du métalangage XML voit le jour en 1998.</p>
<p>La description rigoureuse permise grâce à cette technologie en fait un outil utilisé à plusieurs fins notamment l’élaboration d’éditions critiques de certains textes, qu’ils soient anciens ou nativement numériques ou encore la description formelle de jeux de données (jusqu’à la création de bases de données). XML peut être associé à un autre langage, le XSL (eXtensible Stylesheet Language), qui décrit comment doit être transformé le XML.</p>
<p>XML est un langage supporté par les navigateurs web et est facilement transformable en HTML et compatible avec le CSS.</p>
<p>Que l’on soit sous système d’exploitation Linux, MacOS ou Windows, le XML peut être saisi et lu dans tous les éditeurs de texte. De plus, le XML a cette particularité de ne pas imposer de règles particulières en dehors de la déclaration de la structure des informations avec des balises ouvrantes et fermantes. Chacun est en capacité de créer ses propres règles de structuration des contenus en XML en créant un schéma (ensemble de régles qui déterminent les agencements des différentes balises entre elles) qui correspond aux besoins de l’écriture.</p>
<p>Par exemple, lors de l’édition d’un article scientifique, comment pouvons-nous définir un auteur ? Si l’on écrit la chaîne de caractère “René Dupont” en bas du texte, nous pouvons par convention de lecture deviner que “René” est le prénom de l’auteur et “Dupont” son nom. Or, pour l’ordinateur, cette chaîne de caractère n’est rien d’autre qu’une série de caractères qui n’a aucune valeur sémantique.</p>
<p>Si l’on saisit cette même chaîne de caractères en XML, on peut commencer par y ajouter une balise <code>&lt;auteur&gt;René Dupont&lt;/auteur&gt;</code> pour signifier explicitement qu’il s’agit de l’auteur du texte.</p>
<p>Toutefois, il est possible de préciser encore plus cette notion d’auteur, en y ajoutant par exemple des balises <code>&lt;prénom&gt;</code> et <code>&lt;nom&gt;</code>. La description de ce qu’est un auteur, pour l’écriture de cet article, devient formelle et explicite. Cependant, pour l’écriture savante, est-ce qu’un auteur est seulement un nom et un prénom ? En fonction des contextes de publication, il est possible qu’un autre agent, la revue, définisse également l’auteur avec d’autres informations telles que l’affiliation académique, une adresse courriel et un identifiant unique comme l’ORCID. L’auteur René Dupont prendrait alors la forme suivante :</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">auteur</span>&gt;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">nom</span>&gt;Dupont&lt;/<span class="kw">nom</span>&gt;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">prenom</span>&gt;René&lt;/<span class="kw">prenom</span>&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">courriel</span>&gt;rene.dupont@parisuniversite.fr&lt;/<span class="kw">courriel</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">affiliation</span>&gt;Université de Paris&lt;/<span class="kw">affiliation</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">ORCID</span>&gt;XXXXXXX&lt;/<span class="kw">ORCID</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">auteur</span>&gt;</span></code></pre></div>
<p>Le format XML est un exemple très explicite. La sémantique du texte y est structurée selon deux dimensions, à la fois en termes de structuration verticale des informations mais aussi dans la saisie des noms des balises qui, en général, renvoient à des éléments lisibles et compréhensibles, ce qui n’est pas le cas de tous les formats. D’autres langages de balisage, notamment ceux dit légers comme le Markdown, l’AsciiDoc ou le reStructuredText, emploient des symboles tels que <code>=</code> ou <code>#</code> pour structurer les informations dans le document. Contrairement à ce que nous avons vu avec le XML, la signification des éléments structurants n’est pas forcément explicite pour une lecture humaine, même si on peut la deviner ou apprendre ce que la balise définit.</p>
<h4 id="définir-le-format">Définir le format</h4>
<p>Le terme format est avant tout un terme technique, il délimite les caractéristiques d’un objet. Ces caractéristiques sont formulées par un certain nombres de données, d’instructions, ou de règles. L’objectif est de disposer d’un consensus pour dialoguer autour d’un objet ou de faire communiquer des processus qui traîtent ou qui produisent des formats.</p>
<p>Le format est une contrainte technique dans des environnements qui peuvent être très divers : formats d’objets physiques comme le papier, formats informatiques que nous connaissons par l’extension des fichiers sur nos ordinateurs, ou formats littéraires concernant l’agencement des mots et des phrases. Nous nous concentrons ici sur les contraintes techniques et informatiques. En fonction des nécessités d’un système d’exploitation, d’un programme informatique ou d’une plateforme en ligne, il faudra utiliser tel ou tel format. Un format qui n’est pas standard (ces caractéristiques doivent être décrites), qui n’est pas ouvert (il est possible de comprendre comment le format fonctionne) ou qui nécessite un environnement très spécifique pour être lu ou transformé va générer beaucoup d’obstacles pour son utilisation.</p>
<p>La contrainte du format est liée à d’autres contraintes comme la compatibilité (quel format peut être lu par quel programme ou logiciel ?), l’interopérabilité (est-ce que le format peut être utilisé de la même façon quel que soit l’environnement ?), la dépendance (de quoi un système a-t-il besoin pour traiter le format) et au libre/open-source (est-ce que le format peut être lu, modifié, partagé ?).</p>
<p>Si le but du format est de constituer une série d’informations compréhensibles, utilisables et communicables, il reste une contrainte forte pour les chaînes de publication. Que ce soit en tant que format d’entrée, format pivot ou format de sortie, il déterminera le fonctionnement de la chaîne.</p>
<p>Enfin, le choix d’un format se fait en fonction de deux paramètres essentiels :</p>
<ul>
<li>le temps : est-ce que le format va devenir obsolète et ne sera plus reconnu par le ou les programmes de la forge ?</li>
<li>la communauté : y a-t-il d’autres personnes en mesure de comprendre le format et d’apporter de l’aide (cas d’usage, solutions techniques, etc.) ?</li>
</ul>
<h3 id="assujetissement-à-larchitexte-et-aux-formats">Assujetissement à l’architexte et aux formats</h3>
<p>Il y a un rapport de force qui s’instaure entre l’éditeur de l’architexte et l’utilisateur. Dans le cas d’un logiciel de traitement de texte, lorsque, par exemple, Microsoft propose une modification de la police par défaut dans une version actualisée de son logiciel MSWord, Microsoft change également les manières d’écrire de tous les individus à travers le monde qui utilisent leur logiciel. Il en va de même pour Stylo, LibreOffice, Ghostwriter, etc.</p>
<p>Si l’on s’arrête à la vision superficielle du texte, comme le propose Goody, on ne voit que les éléments graphiques mais nous oublions aussi ceux qui sont invisibles et disparaissent sous la page écranique.</p>
<p>Certes les interfaces d’écriture sont présentées sous la forme de gabarit que l’on doit remplir, comme c’est par exemple le cas des logiciels de création de diapositives dont chacune est découpée en sections contenant tour à tour des images, des titres ou du texte.</p>
<p>Nous avons affaire à une construction visuelle du document, dont la lecture repose sur des conventions culturelles de lecture. À ce sujet, Tufte a publié un article sur les PowerPoint …</p>
<p>Toutefois, l’assujetissement à l’architexte dépasse cette surcouche graphique et concerne également la sous-couches invisibles de structuration textuelle du texte, mais aussi tout le processus d’inscription du document sur son support et les méthodes pour y accéder. Comme nous l’avons précédemment, ce n’est pas l’image du texte affichée à l’écran qui est sauvegardée et archivée mais bien une suite de caractères binaires dont l’écriture intermédiaire est une suite de symboles, de chiffres et de lettres. Dans le cas de certains logiciels propriétaires, comme le logiciel Pages édité par la firme Apple, le document n’est lisible que dans un environnement spécifique et dédié au détriment d’autres environnements d’écriture et lecture. Un document dont le format est <code>.pages</code> ne sera pas lisible dans un environnement Linux ou Windows.</p>
<p>F. Kittler évoquait une écriture aveugle en s’appuyant sur le cas de la cécité de Nietzsche et de sa machine à écrire lui permettant d’écrire malgré sa condition. À partir de cet exemple, Kittler démontre que l’écriture ne peut plus être définie selon l’acte de lecture qui l’accompagne. Voir la contradiction avec la controverse sur l’écriture montrée précédemment.</p>
<p>Ce phénomène est aussi applicable à l’ordinateur et plus largement au numérique. Le non capacité de lecture/interprétation d’un texte par un ordinateur dans le cas d’un document dont le format n’est pas déchiffrable n’empêche pas l’ordinateur d’écrire à cet emplacement même.</p>
<p>Ajouter l’exemple de Kenneth Goldsmith.</p>
<p>De la même manière, le type de support sur lequel est sauvegardé une information pose les questions d’accessiblité, de perennité, d’interopérabilité, etc… L’exemple illustrant au mieux cette question est la disquette : qui aujourd’hui peut lire le contenu d’une disquette ?</p>
<p>Reprendre Kittler sur le mode protégé et le logiciel n’existe pas sur l’assujetissement.</p>
<p>L’auteur devient « usager » = sujet (assujetti) aux logiciels…</p>
<h2 id="étude-de-cas-léditeur-de-texte-stylo">Étude de cas : l’éditeur de texte Stylo</h2>
<p>Dans cette deuxième partie du chapitre, nous étudions la version 3 de l’éditeur de texte sémantique Stylo afin d’observer ce que cet outil écrit dans le texte. Le point de vue adopté qualifie Stylo en tant qu’agent actif de l’écriture et non plus comme un simple environnement d’écriture. L’objectif de cette étude est de montrer que Stylo est plus qu’un espace dédié à l’écriture savante et qu’il y contribue.</p>
<p>La méthode appliquée à l’observation de Stylo est empruntée à F. Kittler et consiste à décrire rigoureusement les techniques et technologies pour en comprendre les effets sur le texte. Lorsqu’un.e utilisateur.rice de Stylo entre du texte sur son clavier, quelles sont les sorties que Stylo donne à ces instructions ?</p>
<h3 id="quest-ce-que-stylo">Qu’est-ce que Stylo ?</h3>
<p>Au préalable de cette étude il convient de faire un point d’introduction sur Stylo.</p>
<p>Stylo est un éditeur de texte sémantique en ligne développé pour l’édition scientifique en sciences humaines et en lettres. Stylo est autant un projet de recherche qu’un outil d’écriture et d’édition, qui entend poser une question décisive : qu’est-ce qu’écrire en environnement numérique en sciences humaines ?</p>
<p>C’est un outil libre et open source conçu en 2017 par la Chaire de recherche du Canada sur les écritures numériques (Vitali-Rosati et al., 2020), et soutenu depuis 2020 par la Très grande infrastructure de recherche Huma-Num. Guillaume Grossetie et Thomas Parisot, tous deux développeurs, travaillent et maintiennent l’infrastructure technique de Stylo avec la CRCEN depuis plusieurs années.</p>
<p>Stylo a pour objectif de transformer le flux de travail numérique des revues savantes en sciences humaines. En tant qu’éditeur de texte sémantique WYSIWYM, il vise à améliorer la chaîne de publication académique (Kembellec 2019), tout en invitant à une réflexion théorique et pratique sur nos façons d’écrire et d’éditer.</p>
<p>Prendre le contrôle de son propre texte, voilà ce que permet aujourd’hui Stylo à travers plusieurs fonctionnalités fondatrices ou toutes nouvelles qui s’inscrivent dans le domaine des technologies de l’édition numérique (Blanc et Haute, 2018) : balisage du texte pour une structure sémantique fine, import de données bibliographiques structurées depuis Zotero, mots-clés contrôlés depuis plusieurs ontologies, prévisualisation avec la possibilité d’annoter, génération de plusieurs formats (HTML, PDF, XML ou DOCX), export respectant les standards de l’édition scientifique, fonctions avancées de rechercher-remplacer, édition collaborative simultanée, accès aux données via une API GraphQL, etc. Contrairement aux outils de traitement de texte tels que Microsoft Word ou LibreOffice, Stylo cherche à promouvoir et à encourager l’utilisation de standards ouverts (Vitali-Rosati, 2020).</p>
<p>Au cœur de Stylo ce sont donc les formats de balisage Markdown, de sérialisation de données YAML ou encore de structuration de références bibliographiques BibTeX qui offrent la possibilité de produire plusieurs formats de sortie depuis une source unique. Pandoc, le « couteau suisse de l’édition », génère les formats de sortie PDF (avec l’aide de LATEX), HTML, XML-TEI ou encore DOCX. Nous traiterons des transformations réalisées par Pandoc dans le prochain chapitre et nous concentrons pour l’instant sur la saisie du texte.</p>
<h4 id="les-briques-logicielles">Les briques logicielles</h4>
<p>Ces trois formats pivots, Markdown, YAML et BibTeX, sont insérés dans tout un écosystème logiciel pour en permettre leur utilisation.</p>
<p>Cette architexture logicielle est scindée en trois parties. Tout d’abord, nous retrouvons la base de données où sont stockées toutes les informations et données de Stylo : les comptes utilisateurs, les articles, les espaces de travail, les corpus, etc. Cette base de données est réalisée avec MongoDB, un système de gestion de base de données non relationnelle développé en 2007 et s’appuyant sur des documents structurés en JSON. Dans Stylo, la structure …</p>
<p>Le deuxième bloc de Stylo concerne l’interface que les utilisateurs voient affichée sur leur écran. Étant donné que Stylo est accessible via un navigateur web, l’interface a été conçue avec les technologies du web. On retrouve des objets en HTML, en CSS et en Javascript. Le <em>framework</em> React, une surcouche à Javascript <em>open source</em> développée par Facebook (aujourd’hui Meta) en 2013, a été employé pour réaliser les différents composants de l’interface et intégrer de nombreux modules tel que le module i18n qui permet d’implémenter le multilinguisme dans l’interface et changer la langue affichée à l’écran en un seul clic. L’éditeur de texte, pièce maîtresse de Stylo, s’appuie sur la technologie Monaco<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> développé par Microsoft et rendu disponible sous licence MIT.</p>
<p>La base de données MongoDB n’est pas stockée dans le même espace que l’interface web. En conséquence, un système de communication devait être établi entre ces deux objets pour que les informations puissent être accessibles, à la fois en écriture et en lecture. Pour mettre en oeuvre cette communication, une API (<em>Application Programming Interface</em>) utilisant le langage de requête GraphQL a été mise en place et rendue accessible via le protocole HTTP (<em>Hypertext Transfer Protocol</em>)<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>, la surcouche du protocole internet utilisée pour le web. Le langage de requête et de manipulation GrapHQL a également été développé par Facebook à partir de 2012 puis publié en <em>open source</em> en 2015.</p>
<p>L’une des particularités d’une API GraphQL, contrairement à une API REST par exemple, est qu’elle sert l’ensemble des données à une seule adresse (<em>endpoint</em>) alors que plus généralement, les données sont accessibles à des URL très précises ce qui a pour effet de rendre explicite la structuration des données dans la base. En ne servant les données qu’à une seule adresse, l’API s’échappe de la contrainte de la structuration des données et contourne les problèmes récurrents d’<em>over-fetching</em> ou d’<em>under-fetching</em> que l’on peut rencontrer dans certaines applications<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>. l’API GraphQL est agnostique vis-à-vis de la forme de la base de données. Par contre, la définition des requêtes adressables à la base de données doit être déclarée pour que l’on puisse faire circuler les informations. Pour cela, GraphQL à son propre langage de description de schéma (<em>SDL</em>, <em>Schema Definition Language</em>) et permet de déclarer explicitement les différentes façons d’écrire une requête.</p>
<p>Par exemple dans Stylo, le champ <code>user</code> contient les informations suivantes<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> :</p>
<ul>
<li>_id</li>
<li>displayName</li>
<li>username</li>
<li>authType</li>
<li>email</li>
<li>firstName</li>
<li>lastName</li>
<li>institution</li>
<li>tags</li>
<li>permissions</li>
<li>acquintances</li>
<li>articles</li>
<li>workspaces</li>
<li>admin</li>
<li>yaml</li>
<li>zoteroToken</li>
<li>createdAt</li>
<li>updatedAt</li>
<li>apiToken</li>
<li>addContact</li>
<li>removeContact</li>
<li>stats</li>
</ul>
<p>Une requête simple consisterait à vouloir directement récupérer l’adresse courriel lié à mon compte utilisateur :</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode graphql"><code class="sourceCode graphql"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">query</span> user {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  user {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    email</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>et renverrait comme réponse :</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode graphql"><code class="sourceCode graphql"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;data&quot;</span>: {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;user&quot;</span>: {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;email&quot;</span>: <span class="st">&quot;roch.delannay@umontreal.ca&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Cet exemple montre qu’il y a une certaine économie de l’information implémentée dans le fonctionnement même de GraphQL pour n’aller chercher que les informations nécessaires pour une requête particulière, pour peu que la requête en elle-même soit bien rédigée. D’ailleurs, il s’agit là d’un des écueils potentiels de GraphQL : des requêtes mal formulées peuvent aller à l’encontre de cette économie.</p>
<p>Dans Stylo, chaque fonctionnalité, chaque bouton (ou presque) qui réalise une action de lecture ou d’écriture est lié à une requête GraphQL. Précédemment nous avons vu que le protocole HTTP comportait deux méthodes bien connues pour faire circuler des informations entre un client et un serveur : <code>GET</code> et <code>POST</code>. Un des arguments phares présenté par GraphQL est sa dimension agnostique par rapport au protocole de communication des informations employé, que ce soit HTTP ou des WebSockets ou autre. Pourtant, malgré la capacité de GraphQL à être utilisable avec toutes les méthodes d’HTTP<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>, une bonne pratique appliquée par la communauté GrapHQL est l’emploi du protocole HTTP couplé à la méthode <code>POST</code> pour tous types de requêtes (que ce soit une <code>query</code>, une <code>mutation</code> ou encore une <code>subscription</code>). Lors de la transmission des informations par la méthode <code>GET</code>, l’ensemble des informations sont insérées dans l’URL ce qui 1) les rend visibles (et vulnérable) et 2) impose une limite du nombre de caractères (au alentours de 2000 au maximum) au risque de déclencher une erreur 414 (URL trop longue). En conséquence, il est préférable d’utiliser la méthode <code>POST</code> pour récupérer des informations car elles ne seront ni visibles ni limitées en longueur, ce qui s’avère nécessaire pour des requêtes parfois trop longues. Malgré l’aspect agnostique de GraphQL, la forme textuelle des requêtes implique en elle-même un choix particulier de transmission des informations avec ce qu’il comporte comme avantages et inconvénients.</p>
<p>Les spécificités du protocoles HTTP sont définies dans les <em>Request for Comments</em> publiés par L’<em>Internet Engineering Task Force</em> (IETF) fondée en 1986, dont le siège se trouve aux États-Unis. Les documents et leurs contenus sont régulièrement mis à jour par la communauté qui participe à ces commentaires. Le numéro de la RFC en lien avec la méthode <code>POST</code> est le 9110<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> publié en juin 2022.</p>
<p>La méthode <code>POST</code> est définie dans le paragraphe 9.3.3 comme :</p>
<blockquote>
<p>The POST method requests that the target resource process the representation enclosed in the request according to the resource’s own specific semantics. For example, POST is used for the following functions (among others): - Providing a block of data, such as the fields entered into an HTML form, to a data-handling process; - Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles; - Creating a new resource that has yet to be identified by the origin server; and - Appending data to a resource’s existing representation(s).<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
</blockquote>
<p>À travers cette brève définition, l’on remarque que l’usage principal de la méthode <code>POST</code> est plutôt relative à l’envoi d’informations, qu’elles soient nouvelles ou mises à jour. Le comportement de <code>POST</code> fait toutefois débat, notamment quant à son usage pour l’envoi de certaines informations puisque, comme cela est indiqué dans sa définition, <code>POST</code> laisse le soin au serveur (la ressource cible) de traiter les données contenues dans son message selon sa propre sémantique. En somme, contrairement à d’autres méthodes comme <code>PUT</code>, <code>POST</code> n’est pas indempotente ce qui pourrait entraîner des différences de résultat lors de l’exécution d’une requête (par exemple, la duplication d’une requête en cas de problème de connexion).</p>
<p>Cependant, cette caractéristique tend à disparaître dans le cas d’une structure GraphQL puisque cette dernière ne dépend pas d’une architecture composée de multiples adresses (une pour chaque ressource) mais d’une seule adresse à laquelle on soumet des requêtes. Dans le cas de Stylo, <code>POST</code> est donc soumis à l’architecture de GraphQL, on peut alors bien considérer GraphQL agnostique à l’égard de la méthode <code>POST</code> du protocole HTTP.</p>
<p>Enfin, dans le cas d’une requête <code>POST</code>, le contenu à envoyer sur le serveur est formaté en JSON.</p>
<p>Ci-dessous un exemple de requête <code>POST</code> envoyée depuis l’interface Web de Stylo vers le serveur :</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span><span class="dt">&quot;query&quot;</span><span class="fu">:</span><span class="st">&quot;query updateWorkingVersion($articleId: ID!, $content: WorkingVersionInput!) {</span><span class="ch">\n</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="st">article(article: $articleId) {</span><span class="ch">\n</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="st">updateWorkingVersion(content: $content) {</span><span class="ch">\n</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="st">updatedAt</span><span class="ch">\n</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="st">}</span><span class="ch">\n</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="st">}</span><span class="ch">\n</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="st">}&quot;</span><span class="fu">,</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="dt">&quot;variables&quot;</span><span class="fu">:{</span><span class="dt">&quot;userId&quot;</span><span class="fu">:</span><span class="st">&quot;61d62c4978651b001208b7aa&quot;</span><span class="fu">,</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="dt">&quot;articleId&quot;</span><span class="fu">:</span><span class="st">&quot;65e0e38129637c001274ef7a&quot;</span><span class="fu">,</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="dt">&quot;content&quot;</span><span class="fu">:{</span><span class="dt">&quot;md&quot;</span><span class="fu">:</span><span class="st">&quot;Ajout du texte pour la requête HTTP `POST`&quot;</span><span class="fu">}}}</span></span></code></pre></div>
<p>Autrement dit, chaque fonctionnalité décrit de manière formelle la structuration des informations dans Stylo, donc ce que Stylo écrit dans la base de données et dans les textes puisque ce sont les informations renseignées qui seront intégrées dans les documents exportés. En ce sens, Stylo et les protocoles auxquels il est assujetti pré-construisent la totalité de ce qu’un utilisateur peut saisir dans l’interface et sera enregistré dans la base de données.</p>
<p>Le dernier bloc de Stylo est le module d’export qui permet de transformer les informations saisies et visibles dans l’éditeur en de multiples documents. Tout ce module réalisé avec le langage de programmation Python est développé et maintenu par David Larlet. Cette brique technologique est articulée autour du logiciel de transformation et de conversion Pandoc<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> déployée sur un serveur et rendue accessible via une autre API<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> fabriquée à partir de <em>framework</em> FastAPI<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>. Le module d’export intégré à Stylo<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> permet de convertir et transformer les textes sources en une multitude d’artefacts, selon les capacités de transformation et de conversion du logiciel Pandoc auquel il est soumis. Les développements autour des transformations des sources de Stylo seront traitées dans le prochain chapitre, nous les laissons donc de côté pour l’instant.</p>
<p>[Faire un shéma de toute la pile techno de Stylo]</p>
<p>Une description très générale des moyens de communication entre les différents modules qui composent Stylo nous montre déjà que l’information qui va être saisie dans cet éditeur de texte est formatée par une architecture de données alors que nous n’avons pas encore abordé les conditions mêmes de l’écriture à savoir les trois formats pivots d’un texte dans Stylo.</p>
<h3 id="les-formats-pivots-de-stylo-en-détail">Les formats pivots de Stylo en détail</h3>
<h4 id="la-sérialisation-des-métadonnées-en-yaml">La sérialisation des métadonnées en YAML</h4>
<h4 id="lécriture-en-markdown">L’écriture en Markdown</h4>
<h4 id="la-saisie-des-références-bibliographiques-en-bibtex">La saisie des références bibliographiques en BibTeX</h4>
<h3 id="écrire-avec-stylo">Écrire avec Stylo</h3>
<p>(Qu’est-ce que Stylo en tant qu’agent qui écrit ?) Dépassement du simple rapport de force énoncé précédemment (grâce à une transparence dans les actions de la machine et l’augmentation de la littératie numérique)</p>
<p>Finalement, après la description de certains des mécanismes à l’oeuvre dans Stylo, nous sommes en droit de nous demander comment se déroule le geste d’écriture dans cet environnement ?</p>
<p>Jusqu’à présent, nous savons que le texte est saisi par l’utilisateur en Markdown (YAML et BibTeX), puis est envoyé sur le serveur au moyen d’une requête GraphQL au format JSON contenue dans une requête HTTP utilisant la méthode <code>POST</code> comme mode de communication. Entre ces étapes persiste une phase que nous n’avons pas encore évoqué : la requête <code>POST</code> envoyé au serveur ne s’effectue pas en continu entre le client et le serveur (ce n’est pas un flux). Une phase latente se glisse dans l’interface Web entre le moment où l’utilisateur frappe les touches de son clavier et le moment où la base de données est mise à jour. Dans ce laps de temps, qu’advient-il du texte ?</p>
<p>Comme cela est mentionné précédemment, l’espace d’écriture est un espace web. Pour y accéder il nous faut un logiciel particulier – un navigateur ou un fureteur – capable d’intpréter du HTML, du CSS et d’exécuter du Javascript. Lorsque l’on écrit dans Stylo (et dans Monaco), le texte saisi doit être manipulable et interprétable par le navigateur pour pouvoir être envoyé sur le serveur. C’est le rôle de Monaco de traiter cette couche d’information. À l’écran, l’utilisateur voit s’afficher du Markdown tel qu’il le frappe, pourtant cette information n’est inscrite sur aucun support en dehors du rendu visuel affiché sur cet écran. Monaco travaille avec des modèles et ce sont avec ces modèles que l’utilisateur interagit. Chaque modèle est rattaché à une URI et c’est de cette manière que Monaco peut manipuler le DOM (<em>Document Object Model</em>) du navigateur pour créer le texte et son rendu graphique en texte brut.</p>
<p>Le DOM est une représentation abstraite d’un document HTML exécutée dans le navigateur. Tous les éléments structurés à l’intérieur de ce document deviennent des objets, des noeuds manipulables avec du Javascript. C’est grâce à ce procédé qu’une page web est rendue dynamique. Puisque le DOM dépend du navigateur, nous pouvons en déduire que ce document sera différent selon le navigateur et la version du logiciel utilisée.</p>
<p>Pour accéder à ce DOM il suffit d’ouvrir les outils de développements du navigateur et d’inspecter le contenu de la page HTML.</p>
<p>Ci-dessous, une première pour montrer le texte saisi à l’écran et une deuxième pour montrer ce qui est écrit dans le DOM :</p>
<figure>
<img src="/images/markdown-stylo.png" alt="Exemple de texte saisi en Markdown dans Stylo" />
<figcaption aria-hidden="true">Exemple de texte saisi en Markdown dans Stylo</figcaption>
</figure>
<figure>
<img src="/images/html-dom.png" alt="DOM du texte saisi dans Stylo" />
<figcaption aria-hidden="true">DOM du texte saisi dans Stylo</figcaption>
</figure>
<p>L’état du texte inscrit dans le DOM est différent de celui qui apparaît à l’écran. Le Markdown se retrouve encapsulé dans des balises attribuées par l’éditeur Monaco et la syntaxe Markdown se retrouve à l’état de texte brut : la balise de titre de niveau 2 (##) n’a plus de valeur sémantique.</p>
<p>Écrire dans un environnement comme Stylo ne consiste pas seulement en une simple saisie du texte à l’écran. Lorsque j’ai l’impression d’écrire au format Markdown, nous écrivons avec Stylo un texte bien différent. Le texte affiché dans Stylo passe en réalité, d’un point de vue matériel, par au moins 4 représentations différentes :</p>
<ul>
<li>le texte saisi en Markdown</li>
<li>la représentation du texte dans le DOM réalisé dans le navigateur par le biais de Monaco</li>
<li>la requête GraphQL envoyée au serveur au format JSON</li>
<li>l’état de sauvegarde sur le serveur dans la base de données MongoDB</li>
</ul>
<p>La seule saisie du texte dans Stylo nécessite en réalité une multitude d’étape intermédiaire cachée aux yeux de l’utilisateur mais que pourtant Stylo rédige et inscrit dans la mémoire numérique.</p>
<p>Chacun de ces états à une signification particulière. Le premier est la projection d’une structure de l’information, tandis que le deuxième en permet l’interprétation et l’affichage par le navigateur, la troisième est une représentation formatée pour circuler entre un client et un serveur et enfin la quatrième est à l’état de stockage, prête à être appelée pour faire le chemin en sens inverse.</p>
<p>Ces différents états du texte sont plus que de simples représentations, ce sont des documents différents et chacun a bien une signification qui lui est propre. Par exemple, la forme en Markdown brut ne peut pas circuler en l’état par le protocole HTTP, il lui manque toute une série d’informations : ce que Stylo écrit dans le texte.</p>
<p>Parmi ces quatre document produits pour écrire, seulement une l’est par l’utilisateur, les autres formes sont écrites par Stylo.</p>
<h2 id="conclusion-1">Conclusion</h2>
<p>Dans sa communication, Stylo met en avant comme argument la reprise en main du texte et de l’écriture, ce qui, comme nous l’avons montré n’est pas complètement vrai. Elle est vrai dans le sens où Stylo propose une chaîne de traitement transparente, libre et ouverte sur les transformations opérées dans le texte. Pourtant, plutôt qu’une reprise en main, il s’agit plutôt d’une déprise au sens que lui donne Louise Merzeau (ref). [ajouter un mot sur la déprise, voir la thèse de N. Sauret pour plus d’informations sur le sujet.]</p>
<p>Nous avons vu que le texte frappé en Markdown, YAML et BibTeX, n’existe pas uniquement sous la forme telle qu’elle est à l’écran mais que d’autres représentations de ce même texte sont générées dans l’espace numérique afin d’être manipulable. On pourrait même aller jusqu’à dire, qu’en dehors des fichiers sources exportés, le document en Markdown n’existe pas : il n’y a aucune document dont l’extension est <code>.md</code> et désigne spécifiquement que ledit document respecte les normes et règles de ce format.</p>
<p>À la différence des systèmes analogiques et continus, la rupture opérée par l’écriture numérique réside entre autre dans cette fragmentation du texte en de multiples textes, chacun circulant dans un canal spécifique.</p>
<p>Dans Stylo, la plupart de ces textes sont écrits par Stylo. La déprise sur le texte survient lors du choix de l’utilisateur de saisir son texte dans Stylo. Lorsqu’un auteur écrit dans Stylo, il accorde sa confiance dans les opérations que réalise Stylo sur le texte et dans la matérialité que l’outil lui confère.</p>
<p>[Citer éditorialisation collaborative d’un événement]</p>
<blockquote>
<p>Comme pour tout dispositif, l’architecture imaginée se définit d’abord « dans une fonction de support, de balise, de cadre organisateur à l’action » (Peeters et Charlier, 1999, p. 19). Dans ce jeu d’applications distribuées, l’événement s’écrit sur ce que Zacklad appelle un « environnement-support » (Zacklad, 2013). Combinant matériel, applicatif, système d’exploitation et infrastructure réseau, le média numérique ne peut plus être pensé comme externalité d’un support : il relève d’une pervasivité par laquelle l’information produit des effets de permanence et d’enveloppement. Circulant d’une situation de communication à une autre, d’un espace de lisibilité à un autre, les contenus ne sont grammatisés que pour se redéployer en permanence, formant moins des séries disjointes et stables (des documents) que des instants d’une expérience ininterrompue. Embarquant « le contexte transactionnel » (Ibid.) qui les conditionne, le dispositif n’est pas une forme, mais une dynamique.</p>
</blockquote>
<p>Faire le lien avec l’intimité du chercheur au croisement du dispositif humain-machine = une organisation particulière des connaissances (voir Zacklad, Szoniecky, Pédauque, Merzeau …)</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>C’est par exemple le cas de la machine à écrire <em>Valentine</em> conçue en 1968 par un designer de renom, Ettore Sottsass, et devenue le produit emblématique de l’entreprise Olivetti. Cette machine a été mise sur le marché en 1969 et est par la suite devenue un objet iconique de la pop culture. Comme nous le verrons plus loin, les mêmes années aux États-Unis, le président Johnson déclare qu’à l’échelle fédérale, les ordinateurs doivent être compatible avec la norme ASCII.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Cette machine a été conçue par Mario Bellini pour Olivetti en 1987, site consulté le 21 février 2024 https://www.moma.org/collection/works/3641<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>La première loi de Moore est relative à l’évolution des processeurs dans le temps et stipule que le nombre de transistors présent dans les processeurs doublera tous les ans pour un coût constant<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Voir la page web correspondante sur le site d’Intel, consulté le 16 février 2024 : https://www.intel.fr/content/www/fr/fr/history/museum-story-of-intel-4004.html<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Voir le site web https://microsoft.github.io/monaco-editor/, consulté lw 29 février 2024.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>L’<em>endpoint</em> de l’API GraphQl de Stylo est accessible ici : https://stylo.huma-num.fr/graphql<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Ces deux problèmes désignent soit une récupération trop importante de données (et nécessite un tri après récupération des données sur le serveur, soit un manque de données pour lequel il faut faire appel une deuxième fois ou plus au serveur pour en récupérer les données)<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Le modélisation du schéma GraphQL est accessible sur le dépôt GitHub de Stylo à l’adresse suivante : https://github.com/EcrituresNumeriques/stylo/blob/master/graphql/models/user.js<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Voir https://graphql.org/learn/serving-over-http/<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>Voir https://www.rfc-editor.org/rfc/rfc9110#name-introduction<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>Traduction personnelle : La méthode POST demande à la ressource cible de traiter la représentation incluse dans la demande selon sa propre sémantique. Par exemple, la méthode POST est utilisée pour les usages suivants (parmi d’autres): Fournir les blocs de données, comme les champs d’un formulaire HTML, à un traitement de données ; Publier un message sur un tableau d’affichage, un groupe d’échange, une liste de diffusion, un blog ou un groupe d’articles similaire ; Créer une nouvelle ressource qui n’a pas encore été identifiée par le serveur d’origine ; et Ajouter des données à la (aux) représentation(s) existante(s) d’une ressource.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>Pandoc est un incontournable pour transformer des documents. Il a été développé et maintenu en Haskell par son créateur John MacFarlane depuis 2006.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>La pandoc-api est accessible à cet <em>endpoint</em>: https://pandoc-api.stylo.huma-num.fr/<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>FastAPI est disponible à cette adresse: https://fastapi.tiangolo.com/<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>On peut trouver le module d’export à cette URL : https://export.stylo.huma-num.fr/<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
            </div>
        </div>
<footer>
    <div>
                <p>CC BY 4.0 Roch Delannay</p>
                <p>Créé avec Pandoc et Make</p>
        <a href="/pages/colophon.html">Colophon</a>
    </div>
</footer>    </body>
</html>