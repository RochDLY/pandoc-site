---
title: "L'écriture numérique est collective"
date: 2024-01-12
---

Résumé : En suivant les pensées de l'éditorialisation et de l'énonciation
éditoriale, l'écriture numérique n'est plus le seul produit d'une fonction
auctoriale, mais d'un ensemble de fonctions éditoriales dont la fonction
auctoriale fait partie.
Cet ensemble comprend à la fois des interventions humaines mais aussi des
interventions réalisées par la machine, à travers une série de choix
technologiques particuliers, que l'on peut englober sous le terme de chaîne
éditoriale.
Selon ce dispositif, et puisque notre hypothèse positionne l'intime en tant que
produit de l'écriture, nous pouvons nous demander si l'ensemble des fonctions
éditoriales ne participeraient-elles pas à produire l'intimité du chercheur et à
transformer ainsi l'intimité en intimité collective ?

[Note : il s'agit certainement de la problématique de toute la thèse, dans cette
partie on peut se focaliser uniquement sur l'apport de la machine dans cette
intimité (et les autres chapitres sur peer review entre autre et les mémoires)]

Parmi toutes les fonctions éditoriales que l'on pourrait énumérer, nous allons
nous concentrer sur la fonction écriture de l'architexte.
Cet environnement peut être découpé en deux parties : les logiciels et les
matériels.
En fonction de la configuration choisie pour écrire, un auteur peut écrire d'une
certaine manière et pas d'une autre.
Yves Jeanneret et Emmanuël Souchier emploient la notion d'architexte pour
expliquer la 
Pour montrer les particularités d'un environnement, une étude sur l'environnement
d'écriture avec l'éditeur de texte sémantique Stylo

## L'écriture numérique

### La controverse sur l'écriture

Définir l'écriture tient généralement de l'anthropologie ou des lettres, la
controverse à ce sujet est très large.
Christin en dresse la cartographie en distingant deux tendances principales :
l'écriture selon les traces ou selon les signes. Dans un cas comme dans l'autre,
ce qui défini finalement l'écriture est l'inscription dans la matière.

### Les particularités de l'écriture numérique

Lorsqu'il s'agit de convoquer _l'écriture numérique_ nous pensons tout de suite
à un ordinateur, aux claviers, aux écrans et au pointeur qui clignote dans un
éditeur de texte ou dans le champ d'un formulaire en ligne.
Avec le numérique ubiquitaire (Citton), ces pratiques d'écriture sont ancrées
dans nos habitudes au point de ne plus les remettre en question (trouver la
ref).
Les dispositifs d'écriture analogique sont ainsi renvoyés à l'état de vestiges
archaïques : par exemple, les machines à écrire, fabriquées méticuleusement
par des ingénieurs et des designers et qui ont fait la fierté et la renommée de
certaines entreprises comme Olivetti en Italie, sont complètement désuètes et
inutilisées depuis une trentaine d'années.
Elles sont aujourd'hui exposées dans des musées (entre autres au MoMA et au
Centre Pompidou) et appartiennent aux collections permanentes ou sont exhibées
lors d'exposition en lien avec les designers
qui les ont conçues^[C'est par exemple le cas de la machine à écrire _Valentine_
conçue en 1968 par un designer de renom, Ettore Sottsass, et devenue le produit
emblématique de l'entreprise Olivetti. Cette machine a été mise sur le marché en
1969 et est par la suite devenue un objet iconique de la pop culture. Comme nous
le verrons plus loin, les mêmes années aux États-Unis, le président Johnson
déclare qu'à l'échelle fédérale, les ordinateurs doivent être compatible avec la
norme ASCII.].

![Machine à écrire portative](https://www.photo.rmn.fr/CorexDoc/RMN/Media/TR1/YECPH3/07-521403.jpg "Machine à écrire portative")

Crédits : © Adagp, Paris. Crédit photographique : Georges Meguerditchian - Centre
Pompidou, MNAM-CCI /Dist. RMN-GP. Réf. image : 4N40151. Diffusion image :
[l'Agence Photo de la RMN](https://www.photo.rmn.fr/C.aspx?VP3=SearchResult&IID=2C6NU0CU7GAD)

![Publicité pour la machine à écrire Valentine](https://www.photo.rmn.fr/CorexDoc/RMN/Media/TR1/VYKH9X/13-519016.jpg "Publicité pour la machine à écrire Valentine")

Crédits :  © Adagp, Paris. Crédit photographique : Jean-Claude Planchet - Centre
Pompidou, MNAM-CCI /Dist. RMN-GP. Réf. image : 4F40212 [2003 CX 6098]. Diffusion
image : [l'Agence Photo de la RMN](https://www.photo.rmn.fr/C.aspx?VP3=SearchResult&IID=2C6NU0DWCD6W)

Pourtant, les derniers modèles fabriqués par ces entreprises l'ont été dans les
années 1980 ou 1990, comme c'est le cas de l'ETP 55 Portable^[Cette machine a 
été conçue par Mario Bellini pour Olivetti en 1987, site consulté le 21 février 2024
https://www.moma.org/collection/works/3641]) et y intègrent des composants
électroniques dès la fin des années 1970.
Les constructeurs ont opéré un changement de paradigme de l'analogique
vers le numérique à ce moment-là et suivi les innovations technologiques
informatiques.
Pour preuve, en 1983, Perry A. King et Antonio Macchi Cassia réussissent
à produire le premier ordinateur personnel d'Olivetti avec le M10 en adaptant un
clavier à un écran à cristaux liquide.
Cet ordinateur, équipé du processeur Intel 80C85 en 8-bits, pouvait également se
connecter à tout un ensemble de périphériques comme des imprimantes.

![Photo d'un M10](http://munk.org/typecast/wp-content/uploads/2014/08/15635.jpg "Photo d'un M10")

Crédits : Photo trouvée sur le blog [Munk.org](https://munk.org/typecast/2014/08/03/back-to-the-future-pram-and-the-promise-of-unified-memory-again/)
le 22 février 2024.

Il faut se rappeler qu'au début des années 1980 il n'est pas encore certain que
l'ordinateur personnel (avec sa tour et son écran à tube cathodique) deviendra
l'outil d'écriture par excellence.
À cette époque, les machines à écrire ont encore quelques avantages sur les
plans esthétique, financier et sociales puisqu'elles sont encore implantées à la
fois dans les sphères professionnelles et personnelles.

Matthew Kirschenbaum détaille dans son ouvrage (ref) la bataille entre les
fournisseurs de logiciels de traitement de texte durant cette décennie pour
obtenir en obtenir le monopole.
Avant l'avènement des interfaces graphiques, la seule chose affichée à l'écran
était un terminal et la navigation se faisait au moyen de commandes (rappeler
les premiers logiciels).
De plus, en dehors de logiciels plus complexe comme `TeX`, développé par Donald
Knuth, il n'était pas aisé de gérer la mise en page des documents depuis des
éditeurs de texte ou premiers traitements de texte.
Ainsi, écrire sur un support connecté paraît aujourd'hui être une évidence alors
qu'elle a demandé de lourds efforts à une époque où cette évidence était
incertaine.

L'écriture numérique est ainsi à distinguer de l'écriture dans un environnement
numérique : un ordinateur, Internet, le Web, une calculatrice ou une
machine à écrire.
En tant qu'abstraction, l'écriture numérique est une représentation du monde
donnée, dont la qualification à travers un medium permet de l'incarner
physiquement mais pas de la circonscrire.
Cette représentation numérique du monde n'est pas nouvelle et ce n'est pas
l'ordinateur qui l'a apporté.
À notre connaissance, son origine remonte aux prémices de l'écriture et des
développements des systèmes monétaires, nous dit C. Herrenschmidt (2007).

Dorénavant, lorsque nous ferons référence à l'écriture numérique nous parlerons
d'une écriture numérique dans un environnement informatique.

L'écriture numérique diffère d'une écriture plus traditionnelle (du monde
de l'imprimerie) et se distingue notamment par deux caractéristiques que sont la
calculabilité et la séparation du geste et de l'inscription.

La première caractéristique est d'ordre computationnel :
l'écriture devient calculable et peut donc faire l'objet d'instructions (Crozat,
Bouchardon, Petit, Kembellec, Herrenschmidt, Vitali-Rosati, Kittler, Bachimont,
Merzeau).
Pour réaliser cette prouesse dans un environnement informatique, on procède a
une équivalence où chaque signe que l'on peut y inscrire à son pendant unique
sous forme de _bits_.
Lorsque chaque caractère peut être identifié en tant que nombre, il devient
possible d'implémenter ce modèle dans une machine et de lui demander, sous forme
d'instructions, d'appliquer des calculs.

L'exemple idéal pour illustrer cette caractéristique n'est rien de moins que la
machine imaginée par Alan Turing, qu'il présente en 1936 dans son article "On
Computable Numbers, with an Application to the Entscheidungsproblem" dans la
section _Computing machines_.
Il ne s'agit pas d'une machine physique mais d'un modèle théorique, une machine
abstraite fondamentale pour les développements futurs de l'informatique.
Cette machine est constituée de plusieurs éléments :

- un ruban (_tape_) divisé en sections (appelées _squares_) dont chacune peut
porter un symbole (0 ou 1 car cette machine est dans un système binaire).
- un organe de lecture (_scan_) pour lire les symboles un à un (_scanned square
and scanned symbol_) et d'écriture pour modifier un symbole ou en écrire une
nouveau si la section est vide
- une mémoire pour se rappeler des sections déjà scannées (_remember some of
the symbols which it has "seen" (scanned) previously_)
- des instructions pour se déplacer sur le ruban, soit une case vers la gauche
soit une case vers la droite, lire et écrire (_scan and print_) ou modifier
la case scannée et se redéplacer (ou s'arrêter).

Théoriquement, le ruban sur lequel la machine exécute ses programmes est infini
vers la gauche et vers la droite et cela afin de permettre l'exécution des
instructions les plus complexes.
La machine de Turing ne s'intéresse pas aux résultats des instructions, ni à
leur signification.
L'espace de la machine, aussi vaste soit-il, n'est composé que de séries de 0 et
de 1 et de différents états, renvoyant à des instructions, permettant ainsi à la
machine de modifier son propre espace.

Le passage du signe à l'unité atomique et discrète qu'est le chiffre signifie un
changement de représentation du monde (cf _worldview_ de K. Hayles) : le monde
n'est alors plus signifié par des mots ou des concepts mais le devient par des
chiffres.
Comme McLuhan nous le rappelle dès 1964, les alphabets composés de lettres
(contrairement à ceux composés de pictogrammes) sont asémantiques.
Si toutefois les alphabets sont liés à une culture d'où ils émergent,
l'abstraction nécessaire pour représenter le monde sous forme de chiffres
détacherait _a priori_ cette vision de tout sens.
En dehors de tout modèle mathématiques abstrait, et cela quel que soit le langage
ou la base utilisée pour l'écrire, `3`, `trois`, `three`, `III`, `0011`,
`zéro zéro un un`, un chiffre ne signifie pas grand chose s'il n'est pas associé
à un système de valeurs particulier, par exemple le système métrique ou le
système international (Herrenschmidt 2007, voir intro).

En échange de cette perte de signification, l'écriture numérique y gagne cette
particularité d'être calculable et mesurable.
Dès lors, il devient possible de mesurer des distances ou des écarts entre des
lettres, des mots ou des concepts, des données dans un environnement donné.

[ajouter une note sur le propos de Luca Paltrienieri]


L'écriture numérique se distingue également des autres
types d'écriture par une deuxième caractéristique.
Il s'agit de la première forme d'écriture où le geste d'écrire
ne correspond pas à l'action d'inscription du signe sur son support.
Lorsqu'on appuie sur une touche du clavier, par exemple la lettre `a`, cette lettre
n'est pas inscrite à l'écran : on donne une instruction à la machine d'inscrire un
signe dans la mémoire de l'ordinateur, puis de l'afficher à l'écran avec un logiciel
particulier (Kittler, Souchier, etc).
Pour comprendre un peu mieux cette particularité, nous pouvons observer le
fonctionnement d'un ordinateur.

### Détails de l'action d'écriture dans l'ordinateur

La représentation d'un ordinateur contemporain est un souvent associé à un couple
matériel/logiciel (que l'on trouve fréquemment sous l'appellation anglaise
_hardware_/_software_).
La partie matérielle concerne tous les composants électroniques (carte mère,
mémoires, périphériques, etc.), alors que la partie logicielle englobe tous les
programmes permettant d'interagir avec la partie matérielle, comme le BIOS
(_Basic Input Output System_), le système d'exploitation ou encore un logiciel
de traitement de texte.

Ce couple matériel/logiciel permet de ranger l'ordinateur dans une catégorie
particulière de machines : les appareils programmables.

La plupart de nos appareils du quotidien ne sont pas programmables : ils
exécutent ce pour quoi ils sont conçus et ne font rien d'autre.
Dans le cas d'un ordinateur (ou d'un téléphone intelligent) ou de tout autre
appareil programmable, ces appareils sont conçus pour être manipulable comme on
le souhaite et d'adapter le traitement des informations en conséquence : ils n'ont pas
une fonction précise, au contraire ce sont des machines capable de répondre à
plusieurs fonctions.
C'est là que les logiciels interviennent : ils permettent un usage déterminé
d'un ordinateur en manipulant des informations de manière à exécuter une suite
d'instructions données.

#### Fonctionnement de la partie matérielle

Pour fonctionner, un ordinateur n'a besoin que des éléments suivants : une
alimentation, un processeur, une mémoire vive, des entrées et sorties et une
carte mère auquel viennent s'ajouter un certains nombre de périphériques
(écrans, souris, clavier, etc.), des extensions pour prendre en charge une
partie des calculs (carte son, carte graphique) et des mémoires de stockage
(disques durs) entre autres.

Le processeur, ou microprocesseur pour les ordinateurs modernes, est le
calculateur central de l'ordinateur, c'est cet élément qui manipule toutes les
données à traiter -- que l'on appelle aussi le(s) coeur(s) de l'ordinateur.
Chaque modèle de processeur à une architecture qui lui est propre, ce qui veut
dire que chacun traite les informations **différemment** (même si le
résultat obtenu est identique).
Un processeur est un assemblage de multiples types de circuits dont l'élément
le plus petit est le transistor.
L'évolution des processeur a suivi la Loi Moore jusqu'au début des années
2020^[La première loi de Moore est relative à l'évolution des processeurs dans le temps et
stipule que le nombre de transistors présent dans les processeurs doublera tous
les ans pour un coût constant], date à partir de laquelle nous arrivons à la
limite physique de la miniaturisation d'un transistor.

Le premier processeur commercialisé, le processeur Intel 4004, l'a été en
1971^[Voir la page web correspondante sur le site d'Intel, consulté le 16
février 2024\ :
https://www.intel.fr/content/www/fr/fr/history/museum-story-of-intel-4004.html].
Il s'agissait d'un processeur 4-bits comportant pas moins de 2300 transistors.
Lors de la commercialisation de cet objet s'opère un changement radical dans la
conception des ordinateurs puisque, dès lors, du fait de la miniaturisation de
ce composant, les ordinateurs deviennent accessibles au grand public.
En suivant la première loi de Moore, les microprocesseurs ont continué à évoluer
jusqu'à atteindre le nombre de plusieurs milliards de transistors par
processeur, démultipliant ainsi leur capacité de traitement des informations.

Cette miniaturisation est rendue possible par la gravure des transistors dans des
disque de silice (_wafer_) plutôt que l'usage plus couteux et instable de relais
et tubes électroniques.
Un transistor est un composant électronique dont le rôle est de laisser passer
le courant ou non grâce aux propriétés du semi-conducteur à partir duquel il est
fabriqué.
En fonction de la valeur du courant qui lui est appliqué, le résultat associé à
cette valeur sera `0` ou `1`.
Ce transistor est l'élément physique qui incarne les portes logiques (ET, OU,
OUI, NON, XOR, etc.) et traitent toutes les données.
Parmi tous les traitements possibles, certains nécessitent de garder en mémoire
des résultats intermédiaires, ainsi, ces données temporaires nécessaires aux
traitements sont enregistrées dans la mémoire vive de l'ordinateur.

Ce stockage intermédiaire mène à la question de la mémoire : on en retrouve
plusieurs types blablabla (RAM et ROM). Le principe de fonctionnement des
mémoires vives (RAM) est le même que pour les processeurs : ce sont des mémoires
construites sur la base de transistors et/ou portes logiques.

Ces informations traitées, transformées et mémorisées proviennent de ce que l'on
nomme des _entrées_ : ce sont elles qui encodent les informations en
chiffres.
Une fois traitées, ou lorsque l'on souhaite s'en servir, ces données passent par
des _sorties_.
Les sorties font le travail inverse des entrées et décodent les chiffres en
signes interprétables.


#### Le codage de l'information
L'encodage et le décodage des caractères accompagne toute l'histoire de
l'informatique (et du numérique).
Au prémices de l'informatique, chaque matériel comportait ses propres programmes
et tables d'encodage, rendant ainsi possible la transposition des données d'un
matériel à un autre.
Cependant, dans la plupart des cas, les données ne pouvaient pas circuler
entre les différents modèles d'ordinateur, ou alors au moyen de transformations
fastidieuses, rendant ainsi les traitements réalisés sur les données enfermés dans
des silos.
La norme ASCII (_American Standard Code for Information Interchange_) fait sont
apparition dans les années 1960 pour résoudre les enjeux liés à l'encodage des données.
Soumise à l'_American Standards Association_ (d'abord ASA puis ANSI) en 1961 par l'un
de ses inventeurs, Bob Bemer, puis approuvée en 1963, l'ASCII permet d'encoder
128 caractères sur 7 bits.
Néanmoins, ce n'est pas parce qu'un encodage est reconnue en tant que norme que
son usage est effectif à l'instant même de la reconnaissance.
Il faut attendre 1968 que le président des États-Unis Johnson demande à ce que
l'ASCII devienne la norme fédérale d'encodage des informations afin de réduire
les incompatibilités au sein des réseaux de télécommunications pour qu'elle
commence à se répandre.
Dès 1969, tous les ordinateurs achetés par le gouvernement des États-Unis
étaient compatibles avec la norme ASCII.
Du côté des ordinateurs personnels, il faudra attendre le début des années 1980
pour que cette norme se répande grâce, entre autre, à son implémentation dans
les ordinateurs construits par IBM.
La norme X3.4:1986 en vigueur aujourd'hui, a été déposée auprès de l'ANSI en 1986.
C'est à partir de cette norme que d'autres ont été développées et sont
compatibles ASCII, comme c'est par exemple le cas pour la norme Unicode, publiée
en 1991, qui est la plus répandue de nos jours, car c'est elle qui encode le plus
de caractères.
Si ASCII contient 128 points de code, le standard Unicode permet d'en encoder
plus de 149 000 sur une vingtaine de bits par point de code dans sa version 15.1
(de 2023).
Afin de préserver cette compatiblité entre les normes, il est d'usage d'encoder
les 128 premiers caractères de façon identique à la norme ASCII.


#### Fonctionnement du software (les différentes piles)

Bios, OS, Logiciels, réseaux (protocoles HTTP, TCP/IP, IMAP, POP, REST,
GrapHQL), communication entre les différentes couches et fonctionnement de
l'inscription dans le disque dur (HDD et SSD).


Le protocole HTTP a été conçu pour permettre la communication entre un client et
un serveur.
Les méthode de communication les plus couramment utilisée sont `GET` et `POST`.
Par convention, et afin de limiter d'éventuels effets de bord, la méthode `GET`
permet de récupérer des informations sur le serveur et de les afficher sur
la page web tandis que `POST` permet de les envoyer depuis le client sur le
serveur, soit pour ajouter une nouvelle entrée, soit pour la modifier.

[Aux machines distantes (Serveurs, fibre optique, ADSL ... Histoire de l'Internet
physique)]

#### Conclusion 
[Si j'écris la chaine de caractère "Hello world" elle passe par (décrire les
éléments) jusqu'à cet encodage dans le disque dur, voir si l'écriture avec une
autre architecture propose un encodage différent]

Ce que l'on remarque en regardant de près cette configuration de l'environnement
d'écriture numérique est qu'il n'est pas possible d'écrire sur le disque dur
sans un agent intermédiaire : le logiciel.

## L'architexte écrit dans le texte

### Définition de l'architexte

Sans l'intervention du logiciel comme médiateur entre l'être humain et le
support d'inscription de l'écriture numérique, il ne serait pas possible pour
l'auteur d'écrire dans cet environnement.
Si l'on considère l'écriture comme le geste d'inscrire une trace ou un signe
dans un support, alors l'écriture numérique n'est plus un fait humain mais un
acte réalisé par l'ordinateur lui-même.

L'interaction entre un humain et une machine consiste en une série
d'instructions que donne l'utilisateur à la machine qui, ensuite, les
exécute.
Le mécanisme sous-jacent à ce que l'on considère communément comme l'écriture
numérique (frapper une touche du clavier et voir la lettre s'afficher à l'écran)
s'avère plus complexe.
Le moment de la frappe n'est plus le moment où le symbole est inscrit dans le
disque dur, mais est le moment où une instruction est donnée à l'ordinateur qui
ensuite se charge d'inscrire la lettre correspondante sur le disque dur.
Si l'on se trouve dans le cas de figure de la saisie d'un texte dans un éditeur
de texte, l'instruction suivante, selon les logiciels et les actions souhaitées,
consiste à afficher le symbole encodé sur le disque dur à l'écran.

Pour réaliser ces actions, Yves Jeanneret et Emmanuël Souchier partent de ce
constat qu'il n'est pas possible d'écrire un texte sans qu'un autre texte soit
déjà présent pour réaliser cette action.
Ce texte particulier qui pré-existe toute activité numérique est nommé
_architexte_ (refs x, x, 2019).

L'architexte a d'abord été employé en littératures par Gérard Genette (1979) et
désigne « l'ensemble des catégories générales, ou transcendentes -- types de
discours, modes d'énonciations, genres littéraires, etc. --, dont relève chaque
texte singulier ».

En 2019, dans l'ouvrage intitulé _Le numérique comme écriture_, Gustavo
Gomez-Mejia, Étienne Candel et Emmanuël Souchier résument la notion d'architexte
comme :

> Initialement défini comme une « écriture d’écriture » puis comme un
« dispositif d’écriture écrit », l’architexte s’avère être un point de passage
obligé pour toute activité numérique. Il n’y a effectivement pas d’écriture à
l’écran sans un architexte qui la rend possible, l’accompagne et la formate.
Pour la première fois de son histoire, l’homme a donc recours à des
« dispositifs d’écriture écrits » spécifiques pour pouvoir pratiquer une
activité d’écriture (E. Souchier, 1998, 2013). Or, précisément en ce qu’ils sont
« eux-mêmes écrits », les architextes « sont des textes lisibles et
interprétables. Porteurs et prescripteurs d’une écriture à venir, ils anticipent
de ce fait une figure de l’auteur » (É. Candel, G. Gomez Mejia, 2013) et
relèvent donc de « l’énonciation éditoriale » (E. Souchier, 1998).

Globalement, l'architexte incarne le cadre dans lequel les agents peuvent
écrire.
Il permet de faire la distinction entre ce que Marie Depret-Lonnet (ref) nomme
gabarit, les espaces proposés par les éditeurs de logiciels ou applications pour
écrire, et le texte saisi par l'utilisateur, c'est-à-dire le texte qui vient
remplir le gabarit.
Cet architexte, ce  cadre, est régit par des règles qui définissent comment l'on
peut écrire mais surtout comment les signes à inscrire doivent être formatés.

#### Revue de la littérature mobilisant l'architexte

Goody

### L'architexte n'est pas qu'une surface

[Revenir sur Christin et sa critique de Goody]

Nous l'avons vu, l'architexte se positionne en tant que médiateur entre un
auteur et la machine qu'il emploie pour écrire.
Jusqu'à présent, la définition de l'architexte englobe largement tous les écrits
qui permettent d'écrire à l'écran.
En 2019 G. Gomez-Mejia, E. Souchier et E. Candel précisent ce que sont ces
méta-écritures et en dressent une typologie composée de quatre « cadres
d'écrits d'écran » :

- le matériel
- le système
- le logiciel
- le document

Le premier cadre, matériel, désigne toute la composante physique de l'ordinateur
et surtout l'écran sur lequel est affiché le texte.
Le cadre système, quant à lui, est associé à la couche permettant de générer un
environnement d'écriture numérique, initialisé par le BIOS, un _firmware_ flashé
dans la mémoire morte de la carte mère de l'ordinateur permettant de réaliser un
certains nombre d'instructions lors de la mise sous tension comme par exemple le
démarrage du système d'exploitation qui constitue le deuxième élément principal
du système.
Le cadre logiciel est relatif à l'ensemble des logiciels que l'on peut exécuter
dans un système d'exploitation, par exemple un terminal, un navigateur ou un
traitement de texte.
Enfin, le dernier cadre est celui du document.
Le document doit être compris comme un objet, ou une forme, déterminé et à
l'intérieur duquel des éléments sémiotiques sont organisés et structurés
(Pédauque (2006, 2007), Zacklad).

Ces cadres sont un début de réponse au dépassement de l'écran.
Néanmoins, plutôt que d'approfondir cette dimension invisible du texte, les
auteurs reviennent sur la couche graphique en ajoutant qu'« à cet enchâssement
de cadres, il faudrait encore ajouter ceux que composent, à l’intérieur même du
document, les rubriques, encadrés, cartouches, « boîtes de dialogue » ou autres
formes de cadres éditoriaux structurants pour le travail même du texte ».

De plus, toujours selon les auteurs :

> Le premier "cadre" [qui] définit les conditions de possibilités matérielles de
l’activité, est le seul inanimé. Les trois suivants, cadres système, logiciel et
document, relèvent de l’ingénierie textuelle et définissent les conditions de
réalisation de l’activité. On voit ainsi qu’une activité d’écriture réalisée sur
le « document » d’un logiciel de traitement de texte est mise en abyme au sein
de l’ensemble des autres « cadres » qui la rendent possible et la déterminent
techniquement et sémiotiquement.

Ce premier cadre de « l'écrit d'écran » ne désigne, pour les auteurs, que
l'écran.
Or, il n'est pas nommé _cadre écran_ mais _cadre matériel_ et devrait renvoyer à
toute la dimension physique d'un ordinateur et pas seulement à l'organe
d'affichage qui, dans cette disposition, apparaît comme central dans le
fonctionnement d'un ordinateur.

Le fait de rendre la couche _hardware_ inanimée dans le production du texte
écrit et de renvoyer cette production aux couches supérieures crée deux
contradictions.
La première contradiction efface la fonction éditoriale du _hardware_,
considérée dès lors comme neutre ce qui, paradoxalement, irait à l'encontre de
l'énonciation éditoriale (Jeanneret & Souchier) dont l'intérêt est l'observation
des dynamiques de production de l'écriture.
La deuxième contradiction repose dans la perception du fonctionnement d'un
ordinateur.
Si l'on pousse ce raisonnement du matériel inanimé, la machine ne pourrait pas
inscrire le texte sur un disque dur.
Or, nous avons vu que, _stricto sensus_, c'est bien la machine qui réalise l'action
d'écrire/inscrire sur le support.
En rendant cette couche inanimée, on y perd la caractéristique de co-écriture
défendue par les auteurs auparavant.
De plus, le renvoi à la surcouche graphique ajoute un masque supplémentaire à ce
que nous essayons de voir en-dessous.
Ce que nous pouvons en comprendre est que, finalement, la notion d'architexte
telle qu'elle est construite par Souchier _et al_, est anthropocentrée et
s'appuie sur des conventions de lecture (_lettrure_) humaines.

Le dépassement de l'écran est un acte symbolique nécessaire pour se soustraire à
une vision anthropocentrée telle qu'elle vient d'être proposée.
Pour ce faire, revenons à l'écriture comme moyen de transmettre une information
au sein d'un système donné.
En l'astreignant à un système d'informations comprenant seulement des agents
humains, il devient difficile d'inclure l'ordinateur comme un agent agissant de
ce système.
Ce système dispose d'un argument de taille (variable) pour nous conforter dans
cette interprétation, l'écran, accompagné d'un objet virtuel qui n'existe que
pour nous réconforter dans notre usage de l'ordinateur : la page.

### Dépassement de l'écran et de la page

Le terme « page » revient de manière récurrente dans nos usages de
l'ordinateur : on le retrouve dans les logiciels de traitement de texte (il y a
même un logiciel du nom de _Pages_ disponible dans l'environnement Apple), dans
les livres numériques ou encore dans le web où chaque URL est l'adresse d'une page.
Matthew Kirschenbaum détaille notamment la relation de l'utilisateur à la page
dans son ouvrage ...

[Ajouter une note sur Kirschenbaum]

Cet objet qu'est la page a été instauré dans l'ordinateur uniquement pour
reproduire une « habitude » et créer un lien fictif entre les visions du monde
de l'imprimerie et de l'informatique.
Cet artefact produit une forme de réconfort auprès de l'utilisateur pour que le
monde informatique lui semble plus tangible, qu'il ait quelque chose auquel se
raccrocher, d'où sa déclinaison dans des espaces différents, comme le web, qui
ne ressemble plus du tout à des pages au format lettre ou A4.
La page affichée à l'écran n'existe qu'à cet endroit, il ne s'agit que d'un
rendu graphique qui ne fait pas partie de l'écriture (au sens du texte saisi).

Le pouvoir de la page sur l'utilisateur est considérable étant donnée la nature
même de cet objet que l'on pourrait considérer comme l'un des seuls à être
virtuel et presque sans matérialité du point de vue de l'informatique.
Malgré tous les efforts effectués depuis son instauration à l'écran, la page
affichée n'est jamais la page imprimée car aussi précis que soient les détails
typographiques que l'on peut y ajuster, elle ne reflétera jamais le grain,
l'épaisseur, l'odeur ou tout autre caractéristique physique du papier.

La critique énoncée à l'endroit de la page ne doit pas être réduite à une
apologie d'un mode sans page.
Elle consiste plutôt à montrer qu'à vouloir préserver une habitude pour « ne pas
effrayer » l'utilisateur, la page fait écran devant l'ordinateur, et cache la
machine qui ne devient plus qu'un simple mécanisme au lieu d'être un agent de
l'énonciation éditoriale.

Cette peur de l'informatique relève essentiellement de l'angoisse de
l'arrachement d'une valeur qui définie l'être humain et devienne une caractéristique
d'une autre entité, ne permettant plus de définir l'humain en regard de ce que lui
seul est capable de faire (Vitali-Rosati).

Kittler, à ce propos, nous rappelle qu'historiquement les caractéristiques
qui définissent l'être humain sont souvent le symbole du pouvoir et désigne
plutôt les hommes alors qu'à l'instant même ou cette caractéristique est
déchue de son statut de marqueur d'une puissance, ce sont les femmes qui en
héritent et deviennent les expertes en ce domaine (Kittler ref).
Il y aurait donc une peur de perdre non seulement une caractéristique de
l'humanité mais surtout une caractéristique de la masculinité.

Néanmoins, avant d'en arriver à cette émotion forte qu'est la peur et qui
traduit la non capacité à définir l'être humain, nous pouvons nous appuyer sur
la pensée de G. Anders et ressentir une forme de honte que l'écran camoufle.

Interagir avec une machine demande une certaine rigueur : qu'il s'agisse de
structurer un document ou de lui donner une série d'instructions (du code), une
machine ne peut interpréter l'ambiguité ou l'implicite culturel.
Cela veut dire qu'aucun échange humain-ordinateur ne peut reposer sur des
conventions culturelles de lecture et que l'instruction donnée n'a, en elle-même, aucun
sens.
Dès lors, comment admettre que quelque chose qui n'a pas de sens puisse en
générer ?

La honte (prométhéenne) d'Anders est alors double : d'un côté il y a un mélange
de fierté devant cette machine créée par l'être humain et de honte parce que
l'individu isolé devant la machine sait que ce n'est pas lui qui l'a mise au
point et, de l'autre, il y a cette honte à être face à un outil qui réalise une
action mieux qu'on ne le ferait soi-même alors que cette dite machine n'a aucune
conscience de ce qu'elle réalise.

Le dépassement de l'écran est une proposition pour poser un autre regard non
anthropocentré sur cette question de l'écriture numérique.
Elle signifie qu'il ne s'agit plus de poser la question de l'auteur de
l'écriture, en admettant que c'est bien la machine qui écrit, et de se demander
comment cette nouvelle fonction (inter)agit entre les agents humains.
Que se passe-t-il lorsque cet ordinateur devient un agent actif qui écrit et
transmet des informations entre, d'une part, l'instructeur (la personne qui
donne des instructions) et la ou les personnes qui lisent les productions
écrites ?
Dans cette configuration s'opère un changement radical de l'état de
l'ordinateur.
Cette machine passe de l'état de médiateur, de support de l'écriture, à celui
d'entité agissante au sein d'un système.





En s'appuyant sur Kittler et sa très célèbre provocation « Es gibt keine
Software », traduit par « Le logiciel n'existe pas » ... 

Katherine Hayles s'inscrit sur les traces de Kittler et propose également une
nouvelle perspective sur l'écriture (My mother was a computer et how we become
posthuman + parole, écriture, code)...


Il y aurait donc une action du côté de la machine...
Le logiciel n'existe pas en tant qu'entité agissante.
Ce n'est ni un agent qui écrit (ni un médiateur).
C'est bien l'ordinateur qui écrit à travers les instructions qu'il reçoit (de
l'utilisateur et de l'éditeur du logiciel de par son code).
Ce qui se trouve entre l'ordinateur et l'auteur est du texte qui permet d'écrire
à la machine d'écrire du texte.
Dans sa conférence sur les logiciels, Kittler démontre que le logiciel est
ramené au même niveau que le reste des écritures par l'ordinateur, c'est-à-dire
au niveau le plus bas (binaire).
En ce sens, les écritures des logiciels ne servent qu'à camoufler le
fonctionnement de la machine.
Un autre particularité des logiciels que souligne Kittler est qu'un logiciel ne
peut pas exister en dehors de son environnement numérique.

L'intermédialité montréalaise peut aider à expliquer ce phénomène (citer ref)

[expliquer intermédialité montréalaise]

Pour aller plus loin dans cette réflexion, nous pouvons même abolir la notion de
média au profit de celle de médiation en mobilisant le texte de Larrue et de
Vitali-Rosati (Media does not exist)...
Cette proposition de Larrue et Vitali-Rosati, qui s'inscrit directement dans la
lignée des travaux de Kittler, permet de faire abstraction de l'objet même
qu'est le média et de se concentrer sur l'interaction _entre_, la médiation.
Finalement, ce n'est pas l'étude du support (physique) qui doit faire l'objet
de l'étude mais la relation ou la dynamique, le _flux_, entre les différents
agents d'où émerge la matérialité.

Kittler fait la même proposition dans sa conférence _Le logiciel n'existe pas_.

Revenir sur la matérialité (en tant que propriété émergente, citer Hayles) du
texte qui est tout sauf affichée sur un écran : l'écran et surtout la surcouche
graphique de mise en page est une illusion créée pour le lecteur humain : elle
a son importance dès lors que le système d'informations prévoit des
destinataires humains mais elle en perd lorsqu'il s'agit d'étudier les relations
entre un ordinateur et un auteur.

Or le principal lectorat des textes numériques sont les robots : les textes
écrits sont écrits avec des machines et principalement pour les machines (c'est,
par exemple, pour cela que le documentaliste déclare formellement les
données)(citer Kembellec etc)

La quest

<!-- Une emphase en italique saisie dans le logiciel Microsoft Word ne sera pas
encodée de la même façon que dans le logiciel InDesign.

[ajouter les deux exemples d'encodage]

C'est en ce sens que l'architexte est le « porteur et [le] prescripteur d'une
écriture à venir » car il dépasse le statut d'interface neutre à l'écran et
devient l'agent qui balise, au sens littéral, le texte.

Néanmoins, cette définition de l'architexte le positionne comme un agent passif
qui ne dépasse pas le statut de cadre de l'écriture.
Or, n'est-ce pas l'architexte lui-même qui interprète l'instruction donnée et
l'applique, c'est-à-dire l'écrit, dans le texte ?

Si l'on reprend l'exemple précédent, lorsque l'on donne pour instruction
d'appliquer une emphase en italique à une chaîne de caractère, c'est bien
le logiciel (une des couches de l'architexte) qui inscrit l'emphase selon le
format qui lui est prédéfini.

Néanmoins, cette écriture réalisée par l'architexte n'est pas rendu visible à
l'écran.
L'affichage de l'écriture à l'écran respecte des conventions de lecture propres
à une culture, elles n'est que rarement affichée dans sa forme la plus verbeuse
(complète)  -->


### Ce que l'architexte inscrit dans le support

#### WYSIWYM vs WYSIWYG

Selon les formats d'écriture, et lorsqu'on sort du paradigme WYSIWYG pour celui
du WYSIWYM, on s'émancipe de la surcouche graphique pour entrer directement dans
la couche de la structuration des contenus.

_What You See Is What You Get_, ou WYSIWYG, est l'acronyme généralement employé
pour désigner les outils qui adoptent une surcouche graphique pour mettre en
page le contenu directement, au risque de ne pas structurer de la façon
souhaitée.
Le paradigme opposé, _What You See Is What You Mean_, distingue la mise en page
(graphique) du texte de sa structuration.
Les formats employées sont généralement en texte brut et permettent souvent de
baliser le contenu pour définir la nature des éléments à décrire.
C'est le cas par exemple de tous les langages de balisages tels HTML ou XML mais
également les langages de balisage léger tels Markdown, AsciiDoc,
reStrucredText,...

Arrivé à ce niveau, l'agent humain ne dépend plus d'un logiciel particulier pour
saisir son texte mais peut faire le choix de l'environnement dans lequel il veut
travailler puisque le texte saisi l'est dans un format brut ce qui, a priori,
est réalisable dans tous les environnements de saisi.

Écrire en texte brut signifie également ouvrir les possibilités de structuration
du texte même : ce n'est plus Microsoft Word ou LibreOffice qui décident de
quelle manière sont structurées les informations mais le choix d'un format ou
d'une saveur particulière d'un format.

L'encodage d'un texte en XML illustre bien ce propos.
XML pour eXtensible Markup Language; est également un métalangage de balisage et
de modélisation du texte.
Plus souple que le HTML dont les balises sont figées, XML permet à chaque
utilisateur de créer son propre système hiérarchique arborescent par
l’élaboration de balises personnalisées.
Postérieur d’une décennie au HTML, la publication des recommandations de la
première version (1.0) du métalangage XML voit le jour en 1998.

La description rigoureuse permise grâce à cette technologie en fait un outil
utilisé à plusieurs fins notamment l’élaboration d’éditions critiques de
certains textes, qu’ils soient anciens ou nativement numériques ou encore la
description formelle de jeux de données (jusqu’à la création de bases de
données).
XML peut être associé à un autre langage, le XSL (eXtensible Stylesheet
Language), qui décrit comment doit être transformé le XML.

XML est un langage supporté par les navigateurs web et est facilement
transformable en HTML et compatible avec le CSS.

Que l'on soit sous système d'exploitation Linux, MacOS ou Windows, le XML peut
être saisi et lu dans tous les éditeurs de texte.
De plus, le XML a cette particularité de ne pas imposer de règles particulières
en dehors de la déclaration de la structure des informations avec des balises
ouvrantes et fermantes.
Chacun est en capacité de créer ses propres règles de structuration des contenus
en XML en créant un schéma (ensemble de régles qui déterminent les agencements
des différentes balises entre elles) qui correspond aux besoins de l'écriture.

Par exemple, lors de l'édition d'un article scientifique, comment pouvons-nous
définir un auteur ?
Si l'on écrit la chaîne de caractère "René Dupont" en bas du texte, nous
pouvons par convention de lecture deviner que "René" est le prénom de l'auteur
et "Dupont" son nom.
Or, pour l'ordinateur, cette chaîne de caractère n'est rien d'autre qu'une série
de caractères qui n'a aucune valeur sémantique.

Si l'on saisit cette même chaîne de caractères en XML, on peut commencer par y
ajouter une balise `<auteur>René Dupont</auteur>` pour signifier explicitement
qu'il s'agit de l'auteur du texte.

Toutefois, il est possible de préciser encore plus cette notion d'auteur, en y
ajoutant par exemple des balises `<prénom>` et `<nom>`.
La description de ce qu'est un auteur, pour l'écriture de cet article, devient
formelle et explicite.
Cependant, pour l'écriture savante, est-ce qu'un auteur est seulement un nom et
un prénom ?
En fonction des contextes de publication, il est possible qu'un autre agent, la
revue, définisse également l'auteur avec d'autres informations telles que
l'affiliation académique, une adresse courriel et un identifiant unique comme
l'ORCID.
L'auteur René Dupont prendrait alors la forme suivante :

```XML
<auteur>
  <nom>Dupont</nom>
  <prenom>René</prenom>
  <courriel>rene.dupont@parisuniversite.fr</courriel>
  <affiliation>Université de Paris</affiliation>
  <ORCID>XXXXXXX</ORCID>
</auteur>
```

Le format XML est un exemple très explicite.
La sémantique du texte y est structurée selon deux dimensions, à la fois en termes
de structuration verticale des informations mais aussi dans la saisie des noms
des balises qui, en général, renvoient à des éléments lisibles et compréhensibles,
ce qui n'est pas le cas de tous les formats.
D'autres langages de balisage, notamment ceux dit légers comme le Markdown,
l'AsciiDoc ou le reStructuredText, emploient des symboles tels que `=` ou `#`
pour structurer les informations dans le document.
Contrairement à ce que nous avons vu avec le XML, la signification des éléments
structurants n'est pas forcément explicite pour une lecture humaine, même si on
peut la deviner ou apprendre ce que la balise définit.

#### Définir le format

Le terme format est avant tout un terme technique, il délimite les
caractéristiques d’un objet. Ces caractéristiques sont formulées par un certain
nombres de données, d’instructions, ou de règles. L’objectif est de disposer
d’un consensus pour dialoguer autour d’un objet ou de faire communiquer des
processus qui traîtent ou qui produisent des formats.

Le format est une contrainte technique dans des environnements qui peuvent être
très divers : formats d’objets physiques comme le papier, formats informatiques
que nous connaissons par l’extension des fichiers sur nos ordinateurs, ou
formats littéraires concernant l’agencement des mots et des phrases.
Nous nous concentrons ici sur les contraintes techniques et informatiques.
En fonction des nécessités d’un système d’exploitation, d’un programme
informatique ou d’une plateforme en ligne, il faudra utiliser tel ou tel format.
Un format qui n’est pas standard (ces caractéristiques doivent être décrites),
qui n’est pas ouvert (il est possible de comprendre comment le format
fonctionne) ou qui nécessite un environnement très spécifique pour être lu ou
transformé va générer beaucoup d’obstacles pour son utilisation.

La contrainte du format est liée à d’autres contraintes comme la compatibilité
(quel format peut être lu par quel programme ou logiciel ?), l’interopérabilité
(est-ce que le format peut être utilisé de la même façon quel que soit
l’environnement ?), la dépendance (de quoi un système a-t-il besoin pour traiter
le format) et au libre/open-source (est-ce que le format peut être lu, modifié,
partagé ?).

Si le but du format est de constituer une série d’informations compréhensibles,
utilisables et communicables, il reste une contrainte forte pour les chaînes de
publication. Que ce soit en tant que format d’entrée, format pivot ou format de
sortie, il déterminera le fonctionnement de la chaîne.

Enfin, le choix d’un format se fait en fonction de deux paramètres essentiels :

- le temps : est-ce que le format va devenir obsolète et ne sera plus reconnu
par le ou les programmes de la forge ?
- la communauté : y a-t-il d’autres personnes en mesure de comprendre le format
et d’apporter de l’aide (cas d’usage, solutions techniques, etc.) ?

### Assujetissement à l'architexte et aux formats

Il y a un rapport de force qui s'instaure entre l'éditeur de l'architexte et
l'utilisateur.
Dans le cas d'un logiciel de traitement de texte, lorsque, par exemple,
Microsoft propose une modification de la police par défaut dans une version
actualisée de son logiciel MSWord, Microsoft change également les manières
d'écrire de tous les individus à travers le monde qui utilisent leur logiciel.
Il en va de même pour Stylo, LibreOffice, Ghostwriter, etc.

Si l'on s'arrête à la vision superficielle du texte, comme le propose Goody, on
ne voit que les éléments graphiques mais nous oublions aussi ceux qui sont
invisibles et disparaissent sous la page écranique.

Certes les interfaces d'écriture sont présentées sous la forme de gabarit que
l'on doit remplir, comme c'est par exemple le cas des logiciels de création de
diapositives dont chacune est découpée en sections contenant tour à tour des
images, des titres ou du texte.

Nous avons affaire à une construction visuelle du document, dont la lecture
repose sur des conventions culturelles de lecture.
À ce sujet, Tufte a publié un article sur les PowerPoint ...

Toutefois, l'assujetissement à l'architexte dépasse cette surcouche graphique et
concerne également la sous-couches invisibles de structuration textuelle du
texte, mais aussi tout le processus d'inscription du document sur son support et
les méthodes pour y accéder.
Comme nous l'avons précédemment, ce n'est pas l'image du texte affichée à
l'écran qui est sauvegardée et archivée mais bien une suite de caractères
binaires dont l'écriture intermédiaire est une suite de symboles, de chiffres et
de lettres.
Dans le cas de certains logiciels propriétaires, comme le logiciel Pages édité
par la firme Apple, le document n'est lisible que dans un environnement
spécifique et dédié au détriment d'autres environnements d'écriture et lecture.
Un document dont le format est `.pages` ne sera pas lisible dans un
environnement Linux ou Windows.

F. Kittler évoquait une écriture aveugle en s'appuyant sur le cas de la cécité
de Nietzsche et de sa machine à écrire lui permettant d'écrire malgré sa
condition.
À partir de cet exemple, Kittler démontre que l'écriture ne peut plus être
définie selon l'acte de lecture qui l'accompagne.
Voir la contradiction avec la controverse sur l'écriture montrée précédemment.

Ce phénomène est aussi applicable à l'ordinateur et plus largement au numérique.
Le non capacité de lecture/interprétation d'un texte par un ordinateur dans le
cas d'un document dont le format n'est pas déchiffrable n'empêche pas
l'ordinateur d'écrire à cet emplacement même.

Ajouter l'exemple de Kenneth Goldsmith.

De la même manière, le type de support sur lequel est sauvegardé une information
pose les questions d'accessiblité, de perennité, d'interopérabilité, etc...
L'exemple illustrant au mieux cette question est la disquette : qui aujourd'hui
peut lire le contenu d'une disquette ?

Reprendre Kittler sur le mode protégé et le logiciel n'existe pas sur
l'assujetissement.

L'auteur devient « usager » = sujet (assujetti) aux logiciels...

## Étude de cas : l'éditeur de texte Stylo
Dans cette deuxième partie du chapitre, nous étudions la version 3 de l'éditeur de
texte sémantique Stylo afin d'observer ce que cet outil écrit dans le texte.
Le point de vue adopté qualifie Stylo en tant qu'agent actif de l'écriture et
non plus comme un simple environnement d'écriture.
L'objectif de cette étude est de montrer que Stylo est plus qu'un espace dédié à
l'écriture savante et qu'il y contribue.

La méthode appliquée à l'observation de Stylo est empruntée à F. Kittler et
consiste à décrire rigoureusement les techniques et technologies pour en
comprendre les effets sur le texte.
Lorsqu'un.e utilisateur.rice de Stylo entre du texte sur son clavier, quelles
sont les sorties que Stylo donne à ces instructions ?

### Qu'est-ce que Stylo ?

Au préalable de cette étude il convient de faire un point d'introduction sur
Stylo.

Stylo est un éditeur de texte sémantique en ligne développé pour l’édition
scientifique en sciences humaines et en lettres.
Stylo est autant un projet de recherche qu’un outil d’écriture et
d’édition, qui entend poser une question décisive : qu’est-ce qu’écrire en
environnement numérique en sciences humaines ?

C'est un outil libre et open source conçu en 2017 par la Chaire de recherche du
Canada sur les écritures numériques (Vitali-Rosati et al., 2020), et soutenu depuis
2020 par la Très grande infrastructure de recherche Huma-Num.
Guillaume Grossetie et Thomas Parisot, tous deux développeurs, travaillent et
maintiennent l'infrastructure technique de Stylo avec la CRCEN depuis plusieurs
années.

Stylo a pour objectif de transformer le flux de travail numérique des revues savantes
en sciences humaines.
En tant qu’éditeur de texte sémantique WYSIWYM, il vise à améliorer la chaîne de
publication académique (Kembellec 2019), tout en invitant à une réflexion théorique et
pratique sur nos façons d’écrire et d’éditer.

Prendre le contrôle de son propre texte, voilà ce que permet aujourd’hui Stylo à
travers plusieurs fonctionnalités fondatrices ou toutes nouvelles qui s’inscrivent
dans le domaine des technologies de l’édition numérique (Blanc et Haute, 2018) :
balisage du texte pour une structure sémantique fine, import de données bibliographiques
structurées depuis Zotero, mots-clés contrôlés depuis plusieurs ontologies,
prévisualisation avec la possibilité d’annoter, génération de plusieurs formats (HTML,
PDF, XML ou DOCX), export respectant les standards de l’édition scientifique,
fonctions avancées de rechercher-remplacer, édition collaborative simultanée, accès aux
données via une API GraphQL, etc.
Contrairement aux outils de traitement de texte tels que Microsoft Word ou
LibreOffice, Stylo cherche à promouvoir et à encourager l’utilisation de standards
ouverts (Vitali-Rosati, 2020).

Au cœur de Stylo ce sont donc les formats de balisage Markdown, de sérialisation de
données YAML ou encore de structuration de références bibliographiques BibTeX qui
offrent la possibilité de produire plusieurs formats de sortie depuis une source
unique.
Pandoc, le « couteau suisse de l’édition », génère les formats de sortie PDF
(avec l’aide de LATEX), HTML, XML-TEI ou encore DOCX.
Nous traiterons des transformations réalisées par Pandoc dans le prochain
chapitre et nous concentrons pour l'instant sur la saisie du texte.

#### Les briques logicielles

Ces trois formats pivots, Markdown, YAML et BibTeX, sont insérés dans tout un
écosystème logiciel pour en permettre leur utilisation.

Cette architexture logicielle est scindée en trois parties.
Tout d'abord, nous retrouvons la base de données où sont stockées toutes les
informations et données de Stylo : les comptes utilisateurs, les articles, les espaces de
travail, les corpus, etc.
Cette base de données est réalisée avec MongoDB, un système de gestion de base
de données non relationnelle développé en 2007 et s'appuyant sur des documents
structurés en JSON.
Dans Stylo, la structure ... 

Le deuxième bloc de Stylo concerne l'interface que les utilisateurs voient affichée
sur leur écran.
Étant donné que Stylo est accessible via un navigateur web,
l'interface a été conçue avec les technologies du web.
On retrouve des objets en HTML, en CSS et en Javascript.
Le _framework_ React, une surcouche à Javascript _open source_ développée par
Facebook (aujourd'hui Meta) en 2013, a été employé pour réaliser les différents
composants de l'interface et intégrer de nombreux modules tel que le module i18n
qui permet d'implémenter le multilinguisme dans l'interface et changer la langue
affichée à l'écran en un seul clic.
L'éditeur de texte, pièce maîtresse de Stylo, s'appuie sur la technologie
Monaco^[Voir le site web https://microsoft.github.io/monaco-editor/, consulté lw
29 février 2024.] développé par Microsoft et rendu disponible sous licence MIT.

La base de données MongoDB n'est pas stockée dans le même espace que l'interface
web.
En conséquence, un système de communication devait être établi entre ces deux
objets pour que les informations puissent être accessibles, à la fois en écriture
et en lecture.
Pour mettre en oeuvre cette communication, une API (_Application Programming
Interface_) utilisant le langage de requête GraphQL a été mise en place et rendue
accessible via le protocole HTTP (_Hypertext Transfer Protocol_)^[L'_endpoint_
de l'API GraphQl de Stylo est accessible ici : https://stylo.huma-num.fr/graphql],
la surcouche du protocole internet utilisée pour le web.
Le langage de requête et de manipulation GrapHQL a également été développé par
Facebook à partir de 2012 puis publié en _open source_ en 2015.

L'une des particularités d'une API GraphQL, contrairement à une API REST par exemple,
est qu'elle sert l'ensemble des données à une seule adresse (_endpoint_) alors
que plus généralement, les données sont accessibles à des URL très précises ce
qui a pour effet de rendre explicite la structuration des données dans la base.
En ne servant les données qu'à une seule adresse, l'API s'échappe de la contrainte
de la structuration des données et contourne les problèmes récurrents
d'_over-fetching_ ou d'_under-fetching_ que l'on
peut rencontrer dans certaines applications^[Ces deux problèmes désignent soit
une récupération trop importante de données (et nécessite un tri après
récupération des données sur le serveur, soit un manque de données pour lequel
il faut faire appel une deuxième fois ou plus au serveur pour en récupérer les
données)].
l'API GraphQL est agnostique vis-à-vis de la forme de la base de données.
Par contre, la définition des requêtes adressables à la base de données doit
être déclarée pour que l'on puisse faire circuler les informations.
Pour cela, GraphQL à son propre langage de description de schéma (_SDL_,
_Schema Definition Language_) et permet de déclarer explicitement les
différentes façons d'écrire une requête.

Par exemple dans Stylo, le champ `user` contient les informations suivantes^[Le
modélisation du schéma GraphQL est accessible sur le dépôt GitHub de Stylo à
l'adresse suivante : https://github.com/EcrituresNumeriques/stylo/blob/master/graphql/models/user.js] :

- _id
- displayName
- username
- authType
- email
- firstName
- lastName
- institution
- tags
- permissions
- acquintances
- articles
- workspaces
- admin
- yaml
- zoteroToken
- createdAt
- updatedAt
- apiToken
- addContact
- removeContact
- stats

Une requête simple consisterait à vouloir directement récupérer l'adresse
courriel lié à mon compte utilisateur :

```graphql
query user {
  user {
    email
  }
}
```

et renverrait comme réponse :

```graphql
{
  "data": {
    "user": {
      "email": "roch.delannay@umontreal.ca"
    }
  }
}
```

Cet exemple montre qu'il y a une certaine économie de l'information implémentée
dans le fonctionnement même de GraphQL pour n'aller chercher que les
informations nécessaires pour une requête particulière, pour peu que la requête
en elle-même soit bien rédigée.
D'ailleurs, il s'agit là d'un des écueils potentiels de GraphQL : des requêtes mal
formulées peuvent aller à l'encontre de cette économie.

Dans Stylo, chaque fonctionnalité, chaque bouton (ou presque) qui réalise une
action de lecture ou d'écriture est lié à une requête GraphQL.
Précédemment nous avons vu que le protocole HTTP comportait deux méthodes bien
connues pour faire circuler des informations entre un client et un serveur :
`GET` et `POST`.
Un des arguments phares présenté par GraphQL est sa dimension agnostique par
rapport au protocole de communication des informations employé, que ce soit HTTP
ou des WebSockets ou autre.
Pourtant, malgré la capacité de GraphQL à être utilisable avec toutes les méthodes
d'HTTP^[Voir https://graphql.org/learn/serving-over-http/], une bonne pratique
appliquée par la communauté GrapHQL est l'emploi
du protocole HTTP couplé à la méthode `POST` pour tous types de requêtes (que ce
soit une `query`, une `mutation` ou encore une `subscription`).
Lors de la transmission des informations par la méthode `GET`, l'ensemble des
informations sont insérées dans l'URL ce qui 1) les rend visibles (et vulnérable)
et 2) impose une limite du nombre de caractères (au alentours de 2000 au maximum)
au risque de déclencher une erreur 414 (URL trop longue).
En conséquence, il est préférable d'utiliser la méthode `POST` pour récupérer
des informations car elles ne seront ni visibles ni limitées en longueur, ce qui
s'avère nécessaire pour des requêtes parfois trop longues.
Malgré l'aspect agnostique de GraphQL, la forme textuelle des requêtes implique
en elle-même un choix particulier de transmission des informations avec ce qu'il
comporte comme avantages et inconvénients.

Les spécificités du protocoles HTTP sont définies dans les _Request for
Comments_ publiés par L'_Internet Engineering Task Force_ (IETF) fondée en 1986,
dont le siège se trouve aux États-Unis.
Les documents et leurs contenus sont régulièrement mis à jour par la communauté
qui participe à ces commentaires.
Le numéro de la RFC en lien avec la méthode `POST` est le 9110^[Voir https://www.rfc-editor.org/rfc/rfc9110#name-introduction]
publié en juin 2022.

La méthode `POST` est définie dans le paragraphe 9.3.3 comme :

> The POST method requests that the target resource process the representation
enclosed in the request according to the resource's own specific semantics.
For example, POST is used for the following functions (among others):
> - Providing a block of data, such as the fields entered into an HTML form, to a
data-handling process;
> - Posting a message to a bulletin board, newsgroup, mailing list, blog, or
similar group of articles;
> - Creating a new resource that has yet to be identified by the origin server; and
> - Appending data to a resource's existing representation(s).^[Traduction
personnelle : La méthode POST demande à la ressource cible de traiter la
représentation incluse dans la demande selon sa propre sémantique. Par exemple,
la méthode POST est utilisée pour les usages
suivants (parmi d'autres): Fournir les blocs de données, comme les champs d'un
formulaire HTML, à un traitement de données ; Publier un message sur un tableau
d'affichage, un groupe d'échange, une liste de diffusion, un blog ou un groupe
d'articles similaire ; Créer une nouvelle ressource qui n'a pas encore été
identifiée par le serveur d'origine ; et Ajouter des données à la
(aux) représentation(s) existante(s) d'une ressource.]

À travers cette brève définition, l'on remarque que l'usage principal de la
méthode `POST` est plutôt relative à l'envoi d'informations, qu'elles soient
nouvelles ou mises à jour.
Le comportement de `POST` fait toutefois débat, notamment quant à son usage pour
l'envoi de certaines informations puisque, comme cela est indiqué dans sa
définition, `POST` laisse le soin au serveur (la ressource cible) de traiter les
données contenues dans son message selon sa propre sémantique.
En somme, contrairement à d'autres méthodes comme `PUT`, `POST` n'est pas
indempotente ce qui pourrait entraîner des différences de résultat lors de
l'exécution d'une requête (par exemple, la duplication d'une requête en cas de
problème de connexion).

Cependant, cette caractéristique tend à disparaître dans le cas d'une structure
GraphQL puisque cette dernière ne dépend pas d'une architecture composée de
multiples adresses (une pour chaque ressource) mais d'une seule adresse à
laquelle on soumet des requêtes.
Dans le cas de Stylo, `POST` est donc soumis à l'architecture de GraphQL, on
peut alors bien considérer GraphQL agnostique à l'égard de la méthode `POST` du
protocole HTTP.

Enfin, dans le cas d'une requête `POST`, le contenu à envoyer sur le serveur est
formaté en JSON.

Ci-dessous un exemple de requête `POST` envoyée depuis l'interface Web de Stylo
vers le serveur :

```JSON
{"query":"query updateWorkingVersion($articleId: ID!, $content: WorkingVersionInput!) {\n
article(article: $articleId) {\n
updateWorkingVersion(content: $content) {\n
updatedAt\n
}\n
}\n
}",
"variables":{"userId":"61d62c4978651b001208b7aa",
"articleId":"65e0e38129637c001274ef7a",
"content":{"md":"Ajout du texte pour la requête HTTP `POST`"}}}
```

Autrement dit, chaque fonctionnalité décrit de manière formelle la structuration
des informations dans Stylo, donc ce que Stylo écrit dans la base de données et
dans les textes puisque ce sont les informations renseignées qui seront
intégrées dans les documents exportés.
En ce sens, Stylo et les protocoles auxquels il est assujetti pré-construisent
la totalité de ce qu'un utilisateur peut saisir dans l'interface et sera
enregistré dans la base de données.

Le dernier bloc de Stylo est le module d'export qui permet de transformer les
informations saisies et visibles dans l'éditeur en de multiples documents.
Tout ce module réalisé avec le langage de programmation Python est développé
et maintenu par David Larlet.
Cette brique technologique est articulée autour du logiciel de transformation et
de conversion Pandoc^[Pandoc est un incontournable pour transformer des
documents. Il a été développé et maintenu en Haskell par son créateur John MacFarlane
depuis 2006.] déployée sur un serveur et rendue accessible via une autre
API^[La pandoc-api est accessible à cet _endpoint_: https://pandoc-api.stylo.huma-num.fr/]
fabriquée à partir de _framework_ FastAPI^[FastAPI est disponible à cette
adresse: https://fastapi.tiangolo.com/].
Le module d'export intégré à Stylo^[On peut trouver le module d'export à cette
URL : https://export.stylo.huma-num.fr/] permet de convertir et transformer les
textes sources en une multitude d'artefacts, selon les capacités de
transformation et de conversion du logiciel Pandoc auquel il est soumis.
Les développements autour des transformations des sources de Stylo seront
traitées dans le prochain chapitre, nous les laissons donc de côté pour
l'instant.


[Faire un shéma de toute la pile techno de Stylo]

Une description très générale des moyens de communication entre les différents
modules qui composent Stylo nous montre déjà que l'information qui va être
saisie dans cet éditeur de texte est formatée par une architecture de données
alors que nous n'avons pas encore abordé les conditions mêmes de l'écriture à
savoir les trois formats pivots d'un texte dans Stylo. 

### Les formats pivots de Stylo en détail

#### La sérialisation des métadonnées en YAML

#### L'écriture en Markdown

#### La saisie des références bibliographiques en BibTeX

### Écrire avec Stylo
(Qu'est-ce que Stylo en tant qu'agent qui écrit ?)
Dépassement du simple rapport de force énoncé précédemment (grâce à une
transparence dans les actions de la machine et l'augmentation de la littératie
numérique)

Finalement, après la description de certains des mécanismes à l'oeuvre dans
Stylo, nous sommes en droit de nous demander comment se déroule le geste
d'écriture dans cet environnement ?

Jusqu'à présent, nous savons que le texte est saisi par l'utilisateur en
Markdown (YAML et BibTeX), puis est envoyé sur le serveur au moyen d'une requête
GraphQL au format JSON contenue dans une requête HTTP utilisant la méthode `POST`
comme mode de communication.
Entre ces étapes persiste une phase que nous n'avons pas encore évoqué : la
requête `POST` envoyé au serveur ne s'effectue pas en continu entre le client et
le serveur (ce n'est pas un flux).
Une phase latente se glisse dans l'interface Web entre le moment où
l'utilisateur frappe les touches de son clavier et le moment où la base de
données est mise à jour.
Dans ce laps de temps, qu'advient-il du texte ?

Comme cela est mentionné précédemment, l'espace d'écriture est un espace web.
Pour y accéder il nous faut un logiciel particulier -- un navigateur ou un
fureteur -- capable d'intpréter du HTML, du CSS et d'exécuter du Javascript.
Lorsque l'on écrit dans Stylo (et dans Monaco), le texte saisi doit être
manipulable et interprétable par le navigateur pour pouvoir être envoyé sur le
serveur.
C'est le rôle de Monaco de traiter cette couche d'information.
À l'écran, l'utilisateur voit s'afficher du Markdown tel qu'il le frappe,
pourtant cette information n'est inscrite sur aucun support en dehors du rendu
visuel affiché sur cet écran.
Monaco travaille avec des modèles et ce sont avec ces modèles que l'utilisateur
interagit.
Chaque modèle est rattaché à une URI et c'est de cette manière que Monaco peut
manipuler le DOM (_Document Object Model_) du navigateur pour créer le texte et
son rendu graphique en texte brut.

Le DOM est une représentation abstraite d'un document HTML exécutée dans le
navigateur.
Tous les éléments structurés à l'intérieur de ce document deviennent des objets,
des noeuds manipulables avec du Javascript.
C'est grâce à ce procédé qu'une page web est rendue dynamique.
Puisque le DOM dépend du navigateur, nous pouvons en déduire que ce document
sera différent selon le navigateur et la version du logiciel utilisée.

Pour accéder à ce DOM il suffit d'ouvrir les outils de développements du
navigateur et d'inspecter le contenu de la page HTML.

Ci-dessous, une première pour montrer le texte saisi à l'écran et une deuxième
pour montrer ce qui est écrit dans le DOM :

![Exemple de texte saisi en Markdown dans Stylo](/images/markdown-stylo.png)

![DOM du texte saisi dans Stylo](/images/html-dom.png)

L'état du texte inscrit dans le DOM est différent de celui qui apparaît à
l'écran.
Le Markdown se retrouve encapsulé dans des balises attribuées par l'éditeur Monaco et
la syntaxe Markdown se retrouve à l'état de texte brut : la balise de titre de
niveau 2 (##) n'a plus de valeur sémantique.

Écrire dans un environnement comme Stylo ne consiste pas seulement en une simple
saisie du texte à l'écran.
Lorsque j'ai l'impression d'écrire au format Markdown, nous écrivons avec Stylo
un texte bien différent.
Le texte affiché dans Stylo passe en réalité, d'un point de vue matériel, par au
moins 4 représentations différentes :

- le texte saisi en Markdown
- la représentation du texte dans le DOM réalisé dans le navigateur par le biais
  de Monaco
- la requête GraphQL envoyée au serveur au format JSON
- l'état de sauvegarde sur le serveur dans la base de données MongoDB

La seule saisie du texte dans Stylo nécessite en réalité une multitude d'étape
intermédiaire cachée aux yeux de l'utilisateur mais que pourtant Stylo rédige et
inscrit dans la mémoire numérique.

Chacun de ces états à une signification particulière.
Le premier est la projection d'une structure de l'information, tandis que le
deuxième en permet l'interprétation et l'affichage par le navigateur, la
troisième est une représentation formatée pour circuler entre un client et un
serveur et enfin la quatrième est à l'état de stockage, prête à être appelée
pour faire le chemin en sens inverse.

Ces différents états du texte sont plus que de simples représentations, ce sont
des documents différents et chacun a bien une signification qui lui est propre.
Par exemple, la forme en Markdown brut ne peut pas circuler en l'état par le
protocole HTTP, il lui manque toute une série d'informations : ce que Stylo
écrit dans le texte.

Parmi ces quatre document produits pour écrire, seulement une l'est par
l'utilisateur, les autres formes sont écrites par Stylo.


## Conclusion 

Dans sa communication, Stylo met en avant comme argument la reprise en main du
texte et de l'écriture, ce qui, comme nous l'avons montré n'est pas complètement
vrai.
Elle est vrai dans le sens où Stylo propose une chaîne de traitement
transparente, libre et ouverte sur les transformations opérées dans le texte.
Pourtant, plutôt qu'une reprise en main, il s'agit plutôt d'une déprise au sens
que lui donne Louise Merzeau (ref).
[ajouter un mot sur la déprise, voir la thèse de N. Sauret pour plus
d'informations sur le sujet.]

Nous avons vu que le texte frappé en Markdown, YAML et BibTeX, n'existe pas
uniquement sous la forme telle qu'elle est à l'écran mais que d'autres
représentations de ce même texte sont générées dans l'espace numérique afin
d'être manipulable.
On pourrait même aller jusqu'à dire, qu'en dehors des fichiers sources exportés,
le document en Markdown n'existe pas : il n'y a aucune document dont l'extension
est `.md` et désigne spécifiquement que ledit document respecte les normes et
règles de ce format.

À la différence des systèmes analogiques et continus, la rupture opérée par
l'écriture numérique réside entre autre dans cette fragmentation du texte en de
multiples textes, chacun circulant dans un canal spécifique.

Dans Stylo, la plupart de ces textes sont écrits par Stylo.
La déprise sur le texte survient lors du choix de l'utilisateur de saisir son
texte dans Stylo.
Lorsqu'un auteur écrit dans Stylo, il accorde sa confiance dans les opérations
que réalise Stylo sur le texte et dans la matérialité que l'outil lui confère.

[Citer éditorialisation collaborative d'un événement]

> Comme pour tout dispositif, l’architecture imaginée se définit d’abord
« dans une fonction de support, de balise, de cadre organisateur à l’action »
(Peeters et Charlier, 1999, p. 19). Dans ce jeu d’applications distribuées,
l’événement s’écrit sur ce que Zacklad appelle un « environnement-support »
(Zacklad, 2013). Combinant matériel, applicatif, système d’exploitation et
infrastructure réseau, le média numérique ne peut plus être pensé comme
externalité d’un support : il relève d’une pervasivité par laquelle
l’information produit des effets de permanence et d’enveloppement.
Circulant d’une situation de communication à une autre, d’un espace de
lisibilité à un autre, les contenus ne sont grammatisés que pour se
redéployer en permanence, formant moins des séries disjointes et stables
(des documents) que des instants d’une expérience ininterrompue.
Embarquant « le contexte transactionnel » (Ibid.) qui les conditionne,
le dispositif n’est pas une forme, mais une dynamique.

Faire le lien avec l'intimité du chercheur au croisement du dispositif
humain-machine = une organisation particulière des connaissances (voir Zacklad,
Szoniecky, Pédauque, Merzeau ...)

